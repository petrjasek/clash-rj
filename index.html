<!DOCTYPE html>
<html lang="cs">
<head>
<meta charset="UTF-8">
<title>Mini Clash Royale s AI</title>
<style>
:root{
    --bg:#0f1115;
    --panel:#151822;
    --panel2:#10131b;
    --text:#e9eefc;
    --muted:#a8b3d6;
    --accent:#6ee7ff;

    --grass1:#2e7d32;
    --grass2:#276a2b;
    --river1:#1b66ff;
    --river2:#1bb1ff;
    --bridge1:#7a5a44;
    --bridge2:#5d4636;

    --red:#ef4444;
    --blue:#3b82f6;
}

body{
    margin:0;
    background:radial-gradient(1200px 700px at 50% -20%, #27325a 0%, var(--bg) 55%),
               radial-gradient(900px 500px at 10% 20%, rgba(110,231,255,.12) 0%, transparent 60%),
               radial-gradient(900px 500px at 90% 20%, rgba(239,68,68,.10) 0%, transparent 60%);
    color:var(--text);
    font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    text-align:center;
}

h1{ margin:18px 0 6px; letter-spacing:.2px; }
p{ color:var(--muted); margin:8px 0; }

#arena{
    width:600px;
    height:450px;
    margin:18px auto;
    position:relative;
    border-radius:18px;
    border:1px solid rgba(255,255,255,.12);
    box-shadow:0 20px 60px rgba(0,0,0,.45);
    overflow:hidden;
    background:
        radial-gradient(120px 120px at 15% 25%, rgba(255,255,255,.08) 0%, transparent 60%),
        radial-gradient(140px 140px at 85% 70%, rgba(255,255,255,.06) 0%, transparent 60%),
        repeating-linear-gradient(45deg, rgba(255,255,255,.06) 0 8px, rgba(255,255,255,.02) 8px 16px),
        linear-gradient(180deg, var(--grass1), var(--grass2));
}

.arena-vignette{
    position:absolute;
    inset:-40px;
    pointer-events:none;
    background:radial-gradient(closest-side, transparent 55%, rgba(0,0,0,.35) 100%);
}

.river{
    position:absolute;
    top:200px;
    width:100%;
    height:50px;
    background:
        linear-gradient(90deg, rgba(255,255,255,.12), rgba(255,255,255,0) 30%, rgba(255,255,255,.10) 60%, rgba(255,255,255,0)),
        repeating-linear-gradient(135deg, rgba(255,255,255,.10) 0 10px, rgba(255,255,255,.04) 10px 20px),
        linear-gradient(180deg, var(--river1), var(--river2));
    background-size:140px 50px, 120px 50px, auto;
    animation:water 3.2s linear infinite;
    box-shadow:inset 0 0 0 1px rgba(255,255,255,.14);
}

@keyframes water{
    from{ background-position:0 0, 0 0, 0 0; }
    to{ background-position:140px 0, -120px 0, 0 0; }
}

.bridge{
    position:absolute;
    top:200px;
    width:88px;
    height:50px;
    border-radius:10px;
    background:
        repeating-linear-gradient(90deg, rgba(255,255,255,.10) 0 8px, rgba(0,0,0,.10) 8px 16px),
        linear-gradient(180deg, var(--bridge1), var(--bridge2));
    box-shadow:0 10px 18px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.10);
}
.bridge.left{ left:106px; }
.bridge.right{ right:106px; }

.tower{
    width:86px;
    height:86px;
    position:absolute;
    border-radius:16px;
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    gap:6px;
    font-weight:800;
    user-select:none;
    box-shadow:0 18px 30px rgba(0,0,0,.35);
    border:1px solid rgba(255,255,255,.16);
}

.tower::before{
    content:"";
    position:absolute;
    top:-10px;
    left:10px;
    right:10px;
    height:16px;
    border-radius:12px;
    background:linear-gradient(180deg, rgba(255,255,255,.24), rgba(255,255,255,.06));
    box-shadow:0 8px 18px rgba(0,0,0,.25);
}

.tower.red{ background:linear-gradient(180deg, rgba(239,68,68,.95), rgba(127,29,29,.92)); bottom:10px; }
.tower.blue{ background:linear-gradient(180deg, rgba(59,130,246,.95), rgba(30,58,138,.92)); top:10px; }

.tower-value{ font-size:20px; line-height:1; color:rgba(255,255,255,.95); }
.tower-hpbar{
    width:72px;
    height:8px;
    border-radius:999px;
    background:rgba(0,0,0,.35);
    overflow:hidden;
    box-shadow:inset 0 0 0 1px rgba(255,255,255,.12);
}
.tower-hpfill{
    height:100%;
    width:100%;
    background:linear-gradient(90deg, #34d399, #22c55e);
}

.unit{
    position:absolute;
    width:44px;
    height:44px;
    transform:translate(-50%, -50%);
    border-radius:999px;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:26px;
    box-shadow:0 10px 16px rgba(0,0,0,.35);
    border:1px solid rgba(255,255,255,.18);
    background:radial-gradient(circle at 30% 25%, rgba(255,255,255,.20), rgba(255,255,255,.04) 55%, rgba(0,0,0,.15));
    user-select:none;
}

/* Make teams very easy to recognize */
.unit.player{
    outline:none;
    border-color:rgba(239,68,68,.55);
    background:
        radial-gradient(circle at 30% 25%, rgba(255,255,255,.22), rgba(255,255,255,.06) 55%, rgba(0,0,0,.18)),
        radial-gradient(circle at 50% 50%, rgba(239,68,68,.22), rgba(239,68,68,0) 70%);
    box-shadow:
        0 10px 16px rgba(0,0,0,.35),
        0 0 0 3px rgba(239,68,68,.22),
        0 0 22px rgba(239,68,68,.18);
}

.unit.ai{
    outline:none;
    border-color:rgba(59,130,246,.55);
    background:
        radial-gradient(circle at 30% 25%, rgba(255,255,255,.22), rgba(255,255,255,.06) 55%, rgba(0,0,0,.18)),
        radial-gradient(circle at 50% 50%, rgba(59,130,246,.22), rgba(59,130,246,0) 70%);
    box-shadow:
        0 10px 16px rgba(0,0,0,.35),
        0 0 0 3px rgba(59,130,246,.22),
        0 0 22px rgba(59,130,246,.18);
}


.unit-face{ line-height:1; transform-origin:50% 50%; }

.unit-value{
    position:absolute;
    top:6px;
    left:50%;
    transform:translateX(-50%);
    font-weight:900;
    font-size:14px;
    color:rgba(255,255,255,.95);
    text-shadow:0 2px 10px rgba(0,0,0,.55);
    pointer-events:none;

.unit.frozen{
    filter:saturate(.75) brightness(1.05);
    box-shadow:
        0 10px 16px rgba(0,0,0,.35),
        0 0 0 3px rgba(147,197,253,.18),
        0 0 20px rgba(59,130,246,.14);
}
}

/* Wall (Zeƒè): wide like bridge, thin like fish */
.unit.wall{
    width:88px;
    height:12px;
    border-radius:10px;
    font-size:0;
    background:linear-gradient(180deg, rgba(203,213,225,.92), rgba(100,116,139,.90));
    border-color:rgba(255,255,255,.14);
    box-shadow:0 10px 16px rgba(0,0,0,.30), inset 0 0 0 1px rgba(255,255,255,.10);
}
.unit.wall.player,
.unit.wall.ai{
    background:linear-gradient(180deg, rgba(203,213,225,.92), rgba(100,116,139,.90));
    border-color:rgba(255,255,255,.14);
    box-shadow:0 10px 16px rgba(0,0,0,.30), inset 0 0 0 1px rgba(255,255,255,.10);
}
.unit.wall .unit-face{ display:none; }

/* X-bow: add a tiny tip marker to guarantee direction */
.unit.xbow-emoji .unit-face{
    position:relative;
    display:block;
}
.unit.xbow-emoji .unit-face::after{
    content:"";
    position:absolute;
    left:50%;
    top:50%;
    width:0;
    height:0;
    transform:translate(16px, -50%);
    border-left:7px solid rgba(255,255,255,.85);
    border-top:4px solid transparent;
    border-bottom:4px solid transparent;
    filter:drop-shadow(0 6px 8px rgba(0,0,0,.22));
    opacity:.85;
}

.unit-hp{
    position:absolute;
    bottom:-10px;
    left:50%;
    width:46px;
    height:7px;
    transform:translateX(-50%);
    border-radius:999px;
    background:rgba(0,0,0,.40);
    overflow:hidden;
    box-shadow:inset 0 0 0 1px rgba(255,255,255,.12);
}
.unit-hpfill{ height:100%; width:100%; background:linear-gradient(90deg, #f59e0b, #ef4444); }

.projectile{
    position:absolute;
    width:8px;
    height:8px;
    border-radius:999px;
    background:radial-gradient(circle, rgba(255,255,255,.9), rgba(255,255,255,.15) 60%, rgba(0,0,0,0));
    box-shadow:0 0 14px rgba(110,231,255,.45);
    transform:translate(-50%, -50%);
    pointer-events:none;
}

.projectile.arrow{
    width:16px;
    height:4px;
    border-radius:999px;
    background:linear-gradient(90deg, rgba(255,255,255,.95), rgba(110,231,255,.65));
    box-shadow:0 0 14px rgba(110,231,255,.35);
}

.projectile.stone{
    width:10px;
    height:10px;
    background:radial-gradient(circle at 30% 30%, rgba(255,255,255,.55), rgba(0,0,0,.10) 40%, rgba(0,0,0,.0) 70%),
               radial-gradient(circle at 55% 55%, rgba(148,163,184,.95), rgba(71,85,105,.65) 60%, rgba(15,23,42,.0) 72%);
    box-shadow:0 0 12px rgba(148,163,184,.25);
}

.explosion{
    position:absolute;
    width:12px;
    height:12px;
    border-radius:999px;
    transform:translate(-50%, -50%);
    pointer-events:none;
    background:radial-gradient(circle, rgba(255,255,255,.95) 0%, rgba(255,255,255,.35) 25%, rgba(255,255,255,0) 70%);
    box-shadow:0 0 28px rgba(255,255,255,.18);
    animation:boom .55s ease-out forwards;
}

.explosion.rocket{
    box-shadow:0 0 34px rgba(110,231,255,.25);
    background:radial-gradient(circle, rgba(110,231,255,.95) 0%, rgba(110,231,255,.28) 28%, rgba(110,231,255,0) 72%);
}

.explosion.slam{
    box-shadow:0 0 34px rgba(239,68,68,.22);
    background:radial-gradient(circle, rgba(239,68,68,.92) 0%, rgba(239,68,68,.22) 30%, rgba(239,68,68,0) 74%);
}

.spell-radius{
    position:absolute;
    left:-9999px;
    top:-9999px;
    width:10px;
    height:10px;
    border-radius:9999px;
    border:2px solid rgba(110,231,255,.55);
    background:radial-gradient(circle, rgba(110,231,255,.10), rgba(110,231,255,0) 70%);
    transform:translate(-50%, -50%);
    pointer-events:none;
    box-shadow:0 0 24px rgba(110,231,255,.12);
    z-index:5;
}

@keyframes boom{
    0%{ opacity:.95; width:14px; height:14px; filter:blur(0px); }
    100%{ opacity:0; width:180px; height:180px; filter:blur(.5px); }
}

#hud{
    width:600px;
    margin:0 auto;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
}

.pill{
    flex:1;
    background:linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.03));
    border:1px solid rgba(255,255,255,.10);
    border-radius:14px;
    padding:10px 12px;
    text-align:left;
}

.elixir-row{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
.elixir-bar{ flex:1; height:10px; background:rgba(0,0,0,.35); border-radius:999px; overflow:hidden; box-shadow:inset 0 0 0 1px rgba(255,255,255,.10); }
.elixir-fill{ height:100%; width:50%; background:linear-gradient(90deg, #a855f7, #22d3ee); }

#ui{
    width:600px;
    margin:10px auto 16px;
    display:flex;
    justify-content:center;
    gap:10px;
    flex-wrap:wrap;
}

.river-fish{
    position:absolute;
    left:40px;
    top:232px;
    transform:translate(-50%, -50%);
    font-size:22px;
    opacity:.9;
    pointer-events:none;
    filter:drop-shadow(0 10px 12px rgba(0,0,0,.35));
    animation:swim 14s linear infinite;
}

@keyframes swim{
    0%{ left:-30px; transform:translate(-50%, -50%) scaleX(1); }
    48%{ left:630px; transform:translate(-50%, -50%) scaleX(1); }
    50%{ left:630px; transform:translate(-50%, -50%) scaleX(-1); }
    98%{ left:-30px; transform:translate(-50%, -50%) scaleX(-1); }
    100%{ left:-30px; transform:translate(-50%, -50%) scaleX(1); }
}

#ui button{
    background:linear-gradient(180deg, rgba(255,255,255,.09), rgba(255,255,255,.02));
    color:var(--text);
    border:1px solid rgba(255,255,255,.12);
    border-radius:14px;
    padding:10px 12px;
    font-size:14px;
    cursor:pointer;
    min-width:140px;
    position:relative;
}

#ui button:hover{ border-color:rgba(110,231,255,.35); }
#ui button.selected{ border-color:rgba(110,231,255,.65); box-shadow:0 0 0 3px rgba(110,231,255,.10); }
#ui button:disabled{ opacity:.45; cursor:not-allowed; }

#log{ width:600px; margin:0 auto 18px; min-height:22px; color:rgba(255,255,255,.85); }

.ability-btn{
    position:absolute;
    right:12px;
    bottom:12px;
    z-index:25;
    background:linear-gradient(180deg, rgba(255,255,255,.09), rgba(255,255,255,.02));
    color:var(--text);
    border:1px solid rgba(255,255,255,.12);
    border-radius:14px;
    padding:10px 12px;
    font-size:14px;
    font-weight:900;
    cursor:pointer;
    min-width:140px;
}
.ability-btn:hover{ border-color:rgba(110,231,255,.35); }
.ability-btn:disabled{ opacity:.45; cursor:not-allowed; }

.end-overlay{
    position:absolute;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    background:rgba(0,0,0,.35);
    backdrop-filter: blur(2px);
    z-index:20;
}

.end-overlay.hidden{ display:none; }

.end-card{
    min-width:260px;
    padding:16px 18px;
    border-radius:16px;
    border:1px solid rgba(255,255,255,.16);
    background:linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
    box-shadow:0 18px 50px rgba(0,0,0,.45);
    font-weight:900;
    font-size:22px;
    color:rgba(255,255,255,.95);
    position:relative;
}

.end-topbar{
    position:absolute;
    top:10px;
    left:10px;
    right:10px;
    display:flex;
    justify-content:space-between;
    gap:10px;
}
.end-topbar button{
    background:linear-gradient(180deg, rgba(255,255,255,.09), rgba(255,255,255,.02));
    color:var(--text);
    border:1px solid rgba(255,255,255,.12);
    border-radius:12px;
    padding:8px 10px;
    font-size:12px;
    font-weight:900;
    cursor:pointer;
}
.end-topbar button:hover{ border-color:rgba(110,231,255,.35); }

.end-panel{
    margin-top:10px;
    padding:10px 12px;
    border-radius:14px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(0,0,0,.18);
    font-size:13px;
    font-weight:700;
    color:rgba(255,255,255,.92);
    text-align:left;
    max-height:200px;
    overflow:auto;
}
.end-panel.hidden{ display:none; }

.end-title{ margin-bottom:12px; }
.end-actions{
    display:flex;
    gap:10px;
    justify-content:space-between;
}
.end-actions button{
    flex:1;
    background:linear-gradient(180deg, rgba(255,255,255,.09), rgba(255,255,255,.02));
    color:var(--text);
    border:1px solid rgba(255,255,255,.12);
    border-radius:14px;
    padding:10px 12px;
    font-size:14px;
    font-weight:800;
    cursor:pointer;
}
.end-actions button:hover{ border-color:rgba(110,231,255,.35); }

.deck-overlay{
    position:absolute;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    background:rgba(0,0,0,.45);
    backdrop-filter: blur(2px);
    z-index:30;
}
.deck-overlay.hidden{ display:none; }
.deck-card{
    width:min(560px, calc(100% - 24px));
    padding:14px 14px 12px;
    border-radius:16px;
    border:1px solid rgba(255,255,255,.16);
    background:linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
    box-shadow:0 18px 50px rgba(0,0,0,.45);
}
.deck-title{ font-weight:900; font-size:18px; margin-bottom:8px; }
.deck-sub{ opacity:.85; margin-bottom:10px; font-size:13px; }
.deck-grid{ display:flex; flex-wrap:wrap; gap:10px; justify-content:center; }
.deck-grid button{ min-width:172px; }
.deck-grid button.picked{ border-color:rgba(110,231,255,.65); box-shadow:0 0 0 3px rgba(110,231,255,.10); }
.deck-actions{ display:flex; justify-content:space-between; align-items:center; margin-top:10px; gap:10px; }
.deck-actions .hint{ opacity:.85; font-size:13px; }
.deck-actions .start{ min-width:180px; }
</style>
</head>
<body>

<h1>Mini Clash Royale üè∞</h1>
<p>Klikni na svoji polovinu pro vykl√°d√°n√≠ jednotky (spodn√≠ ƒç√°st ar√©ny).</p>

<div id="arena">
    <div class="river"></div>

    <div class="river-fish" aria-hidden="true">üêü</div>
    <div class="bridge left"></div>
    <div class="bridge right"></div>
    <div class="arena-vignette"></div>

    <!-- MODR√â Vƒö≈ΩE -->
    <div class="tower blue" style="left:60px" id="ai0"></div>
    <div class="tower blue" style="left:260px" id="ai1"></div>
    <div class="tower blue" style="left:460px" id="ai2"></div>

    <!-- ƒåERVEN√â Vƒö≈ΩE -->
    <div class="tower red" style="left:60px" id="pl0"></div>
    <div class="tower red" style="left:260px" id="pl1"></div>
    <div class="tower red" style="left:460px" id="pl2"></div>

    <div id="endOverlay" class="end-overlay hidden" aria-live="polite">
        <div class="end-card">
            <div class="end-topbar">
                <button id="endTrophyRoad">üèÜ Trophy road</button>
                <button id="endLeaderboard">üìã Leaderboard</button>
            </div>
            <div class="end-title" id="endText"></div>
            <div id="endPanel" class="end-panel hidden"></div>
            <div class="end-actions">
                <button id="endSame">Hr√°t se stejn√Ωma kartama</button>
                <button id="endNew">Hr√°t s jin√Ωma kartama</button>
            </div>
            <div class="end-actions" style="margin-top:10px;">
                <button id="endRandom">Hra s random kartama</button>
            </div>
        </div>
    </div>

    <div id="deckOverlay" class="deck-overlay" aria-live="polite">
        <div class="deck-card">
            <div class="deck-title">Vyber 4 karty</div>
            <div class="deck-sub">Klikni na karty (mus√≠ b√Ωt p≈ôesnƒõ 4), pak stiskni Start.</div>
            <div class="deck-grid" id="deckGrid"></div>
            <div class="deck-actions">
                <div class="hint" id="deckHint">Vybr√°no: 0 / 4</div>
                <button class="start" id="deckStart" disabled>Start</button>
            </div>
        </div>
    </div>

    <button id="moleAbility" class="ability-btn" disabled>ü™è Krtek (1‚ö°)</button>
</div>

<div id="hud">
    <div class="pill">
        <div class="elixir-row">
            <div>‚ö° Elix√≠r: <strong><span id="elixir">5</span></strong> / 10</div>
            <div style="opacity:.85">AI: <strong><span id="aiElixir">5</span></strong></div>
        </div>
        <div class="elixir-row" style="margin-top:6px; font-size:13px; opacity:.95;">
            <div>‚è±Ô∏è ƒåas: <strong><span id="timeLeft">1:00</span></strong></div>
            <div>üèÜ Trophy: <strong><span id="trophies">0</span></strong></div>
        </div>
        <div class="elixir-bar" aria-hidden="true"><div class="elixir-fill" id="elixirFill"></div></div>
    </div>
</div>

<div id="ui">
    <!-- Hand is rendered by JS (4 cards) -->
</div>

<p id="log"></p>

<script>
const arena = document.getElementById("arena");
const ARENA_W = 600;
const ARENA_H = 450;
const RIVER_Y = 200;
const RIVER_H = 50;
const BRIDGES_X = [150, 450];
const BRIDGE_Y = RIVER_Y + RIVER_H / 2;

let elixir = 5;
let aiElixir = 5;
let selectedCard = null;
let lastAiSpawnMs = 0;
let lastTickMs = performance.now();
let gameOver = false;
let lastAiUnitCardId = null;
let gameStarted = false;
let playerRotWall = null;
let playerMole = null;
let moleCooldownUntilMs = 0;
const MOLE_TUNNEL_COST = 1;
const ALL_CARDS = [1,2,3,5,6,7,8,9,10,11,12,13,14,15];
const HAND_SIZE = 4;
let playerHand = [];
let aiHand = [];
let lastPlayerUsedCardId = null;
let lastAiUsedCardId = null;

// Match rules
const MATCH_MS = 120_000;
const SUDDEN_DEATH_TOWER_DRAIN_PER_SEC = 10;
let matchStartMs = 0;
let inSuddenDeath = false;

let playerDeck = [];
let selectedDeck = new Set();

let lastAiStartHandKey = null;

function handKey(hand){
    return [...hand].slice().sort((a,b)=>a-b).join(",");
}

function pickAiStartHandDifferent(){
    // Try a few times to avoid the same 4 cards as last round
    const pool = getUnlockedPool();
    let candidate = shuffle([...pool]).slice(0, HAND_SIZE);
    if(!lastAiStartHandKey){
        lastAiStartHandKey = handKey(candidate);
        return candidate;
    }
    for(let i=0;i<12;i++){
        const key = handKey(candidate);
        if(key !== lastAiStartHandKey){
            lastAiStartHandKey = key;
            return candidate;
        }
        candidate = shuffle([...pool]).slice(0, HAND_SIZE);
    }
    // Fallback: accept (extremely unlikely unless pool is tiny)
    lastAiStartHandKey = handKey(candidate);
    return candidate;
}

const logEl = document.getElementById("log");
const elixirEl = document.getElementById("elixir");
const aiElixirEl = document.getElementById("aiElixir");
const elixirFillEl = document.getElementById("elixirFill");
const timeLeftEl = document.getElementById("timeLeft");
const trophiesEl = document.getElementById("trophies");
const endOverlayEl = document.getElementById("endOverlay");
const endTextEl = document.getElementById("endText");
const endPanelEl = document.getElementById("endPanel");
const endSameBtn = document.getElementById("endSame");
const endNewBtn = document.getElementById("endNew");
const endRandomBtn = document.getElementById("endRandom");
const endTrophyRoadBtn = document.getElementById("endTrophyRoad");
const endLeaderboardBtn = document.getElementById("endLeaderboard");
const moleAbilityBtn = document.getElementById("moleAbility");

const TROPHIES_KEY = "mini_cr_trophies_v1";
const LEADERBOARD_KEY = "mini_cr_leaderboard_v1";
let trophies = Number(localStorage.getItem(TROPHIES_KEY) || 0) || 0;

function saveTrophies(){
    trophies = Math.max(0, Math.floor(trophies));
    localStorage.setItem(TROPHIES_KEY, String(trophies));
}

function loadLeaderboard(){
    try{
        const raw = localStorage.getItem(LEADERBOARD_KEY);
        const arr = raw ? JSON.parse(raw) : [];
        return Array.isArray(arr) ? arr : [];
    }catch(e){
        return [];
    }
}

function saveLeaderboard(list){
    try{ localStorage.setItem(LEADERBOARD_KEY, JSON.stringify(list)); }catch(e){}
}

function pushLeaderboardEntry(){
    const list = loadLeaderboard();
    list.push({ trophies, at: new Date().toISOString() });
    list.sort((a,b)=> (b.trophies||0) - (a.trophies||0));
    saveLeaderboard(list.slice(0, 25));
}

function trophyDelta(playerWon, playerAliveTowers){
    const n = Math.max(0, Math.min(3, playerAliveTowers));
    const base = (n === 3 ? 30 : (n === 2 ? 20 : 10));
    return playerWon ? base : -base;
}

function getUnlockedPool(){
    // Base unlocked at start
    const pool = new Set([3,2,13,1]);
    if(trophies >= 100){
        [9,6,8,7].forEach(id=>pool.add(id));
    }
    if(trophies >= 250){
        [12,14,11].forEach(id=>pool.add(id));
    }
    if(trophies >= 500){
        [5,10].forEach(id=>pool.add(id));
    }
    if(trophies >= 750){
        [15].forEach(id=>pool.add(id));
    }
    return [...pool].filter(id=>ALL_CARDS.includes(id));
}

function trophyRoadHtml(){
    const line = (need, ids)=>{
        const unlocked = trophies >= need;
        const items = ids.map(id=>{
            const c = cards[id];
            return c ? `${c.emoji} ${c.name}` : `#${id}`;
        }).join(" ¬∑ ");
        return `${unlocked ? "‚úÖ" : "üîí"} ${need}üèÜ: ${items}`;
    };
    const base = [3,2,13,1].map(id=>{ const c = cards[id]; return c ? `${c.emoji} ${c.name}` : `#${id}`; }).join(" ¬∑ ");
    return [
        `Tvoje trophy: <strong>${trophies}</strong>`,
        `‚úÖ 0üèÜ: ${base}`,
        line(100,[9,6,8,7]),
        line(250,[12,14,11]),
        line(500,[5,10]),
        line(750,[15])
    ].join("<br>");
}

function leaderboardHtml(){
    const list = loadLeaderboard().slice().sort((a,b)=> (b.trophies||0) - (a.trophies||0)).slice(0, 10);
    if(list.length === 0) return "Zat√≠m pr√°zdn√©.";
    return list.map((e,i)=>{
        const when = (e.at ? e.at.slice(0,10) : "");
        return `${i+1}. ${e.trophies}üèÜ <span style=\"opacity:.75\">${when}</span>`;
    }).join("<br>");
}

function toggleEndPanel(mode){
    if(!endPanelEl) return;
    if(endPanelEl.dataset.mode === mode && !endPanelEl.classList.contains("hidden")){
        endPanelEl.classList.add("hidden");
        endPanelEl.dataset.mode = "";
        endPanelEl.innerHTML = "";
        return;
    }
    endPanelEl.classList.remove("hidden");
    endPanelEl.dataset.mode = mode;
    endPanelEl.innerHTML = (mode === "road") ? trophyRoadHtml() : leaderboardHtml();
}

if(endTrophyRoadBtn) endTrophyRoadBtn.onclick = ()=>toggleEndPanel("road");
if(endLeaderboardBtn) endLeaderboardBtn.onclick = ()=>toggleEndPanel("lb");

function updateMoleAbilityUi(nowMs = performance.now()){
    if(!moleAbilityBtn) return;
    const haveMole = !!(playerMole && playerMole.hp > 0);
    const cdLeft = Math.max(0, moleCooldownUntilMs - nowMs);
    const ready = haveMole && cdLeft <= 0 && !gameOver && gameStarted;
    const canPay = elixir >= MOLE_TUNNEL_COST;
    moleAbilityBtn.disabled = !(ready && canPay);
    if(!gameStarted){
        moleAbilityBtn.innerText = `ü™è Krtek (${MOLE_TUNNEL_COST}‚ö°)`;
        return;
    }
    if(!haveMole){
        moleAbilityBtn.innerText = `ü™è Krtek (${MOLE_TUNNEL_COST}‚ö°)`;
        return;
    }
    if(cdLeft > 0){
        moleAbilityBtn.innerText = `ü™è Krtek (${Math.ceil(cdLeft/1000)}s)`;
        return;
    }
    moleAbilityBtn.innerText = `ü™è Krtek (${MOLE_TUNNEL_COST}‚ö°)`;
}

if(moleAbilityBtn){
    moleAbilityBtn.addEventListener("click", ()=>{
        const nowMs = performance.now();
        if(gameOver || !gameStarted) return;
        if(!playerMole || playerMole.hp <= 0){
            setLog("Nem√°≈° ≈æ√°dn√©ho krtka.");
            updateMoleAbilityUi(nowMs);
            return;
        }
        if(nowMs < moleCooldownUntilMs){
            setLog("ü™è Schopnost je na cooldownu.");
            updateMoleAbilityUi(nowMs);
            return;
        }
        if(elixir < MOLE_TUNNEL_COST){
            setLog("Nem√°≈° dost elix√≠ru.");
            updateMoleAbilityUi(nowMs);
            return;
        }

        elixir -= MOLE_TUNNEL_COST;
        moleCooldownUntilMs = nowMs + 10000;

        spawnExplosion(playerMole.x, playerMole.y, "rocket");
        playerMole.x = clamp(ARENA_W - playerMole.x, 18, ARENA_W-18);
        playerMole.hp = playerMole.maxHp;
        spawnExplosion(playerMole.x, playerMole.y, "rocket");
        renderUnit(playerMole);
        setLog("ü™è Krtek se zakopal a vyhrabal na druh√© stranƒõ!");
        updateHud();
    });
}

const spellPreviewEl = document.createElement("div");
spellPreviewEl.className = "spell-radius";
arena.appendChild(spellPreviewEl);

function hideSpellPreview(){
    spellPreviewEl.style.left = "-9999px";
    spellPreviewEl.style.top = "-9999px";
}

function tryReflectSpellByShield(tower){
    if(!tower || tower.hp <= 0) return null;
    if(!tower.isTower) return null;
    if(!tower.shieldCharges || tower.shieldCharges <= 0) return null;

    tower.shieldCharges -= 1;
    renderTower(tower);
    spawnExplosion(tower.x, tower.y, "rocket");

    const enemyTowers = tower.team === "player" ? aiTowers : playerTowers;
    const alive = enemyTowers.filter(t=>t.hp>0);
    if(alive.length === 0) return null;
    return alive[Math.floor(Math.random()*alive.length)];
}

function updateSpellPreview(x, y){
    if(!selectedCard || !gameStarted || gameOver){
        hideSpellPreview();
        return;
    }
    const card = cards[selectedCard];
    if(!card || card.type !== "spell"){
        hideSpellPreview();
        return;
    }

    // Only show AoE preview for Rocket/Zap/Skel barell
    const radius = (card.rocket && card.rocket.radius) || (card.zap && card.zap.radius) || (card.barrel && card.barrel.radius);
    if(!radius){
        hideSpellPreview();
        return;
    }

    const tx = clamp(x, 20, ARENA_W-20);
    const ty = clamp(y, 20, ARENA_H-20);
    spellPreviewEl.style.width = (radius*2) + "px";
    spellPreviewEl.style.height = (radius*2) + "px";
    spellPreviewEl.style.left = tx + "px";
    spellPreviewEl.style.top = ty + "px";
}

let playerTowers = [
    {hp:200, maxHp:200, x:60+43, y:ARENA_H-10-43, element: document.getElementById("pl0"), isTower:true, team:"player", lastShotMs:0, shieldCharges:0},
    {hp:500, maxHp:500, x:260+43, y:ARENA_H-10-43, element: document.getElementById("pl1"), isTower:true, team:"player", lastShotMs:0, shieldCharges:0},
    {hp:200, maxHp:200, x:460+43, y:ARENA_H-10-43, element: document.getElementById("pl2"), isTower:true, team:"player", lastShotMs:0, shieldCharges:0}
];

let aiTowers = [
    {hp:200, maxHp:200, x:60+43, y:10+43, element: document.getElementById("ai0"), isTower:true, team:"ai", lastShotMs:0, shieldCharges:0},
    {hp:500, maxHp:500, x:260+43, y:10+43, element: document.getElementById("ai1"), isTower:true, team:"ai", lastShotMs:0, shieldCharges:0},
    {hp:200, maxHp:200, x:460+43, y:10+43, element: document.getElementById("ai2"), isTower:true, team:"ai", lastShotMs:0, shieldCharges:0}
];

let playerUnits = [];
let aiUnits = [];
let projectiles = [];

function setLog(msg){
    logEl.innerText = msg;
}

function aliveTowerCount(side){
    const arr = (side === "player") ? playerTowers : aiTowers;
    return arr.filter(t => t.hp > 0).length;
}

function middleTowerAlive(side){
    const arr = (side === "player") ? playerTowers : aiTowers;
    return !!(arr[1] && arr[1].hp > 0);
}

function getTimeLeftMs(nowMs){
    if(!matchStartMs) return MATCH_MS;
    return Math.max(0, MATCH_MS - (nowMs - matchStartMs));
}

function updateHudTimeAndTrophies(nowMs){
    if(timeLeftEl){
        if(inSuddenDeath){
            timeLeftEl.textContent = "Sudden death";
        }else{
            const t = getTimeLeftMs(nowMs);
            const s = Math.ceil(t/1000);
            const mm = Math.floor(s/60);
            const ss = String(s%60).padStart(2,'0');
            timeLeftEl.textContent = `${mm}:${ss}`;
        }
    }
    if(trophiesEl){
        trophiesEl.textContent = `üèÜ ${trophies}`;
    }
}

function applySuddenDeathDrain(dtSec){
    const dmg = SUDDEN_DEATH_TOWER_DRAIN_PER_SEC * dtSec;
    if(dmg <= 0) return;
    for(const t of playerTowers){
        if(t.hp <= 0) continue;
        t.hp = Math.max(0, t.hp - dmg);
        renderTower(t);
    }
    for(const t of aiTowers){
        if(t.hp <= 0) continue;
        t.hp = Math.max(0, t.hp - dmg);
        renderTower(t);
    }
}

function arenaCoordsFromEvent(e){
    const rect = arena.getBoundingClientRect();
    const scaleX = ARENA_W / rect.width;
    const scaleY = ARENA_H / rect.height;
    const x = (e.clientX - rect.left) * scaleX;
    const y = (e.clientY - rect.top) * scaleY;
    return { x, y };
}

function updateHud(){
    elixirEl.innerText = elixir;
    aiElixirEl.innerText = aiElixir;
    elixirFillEl.style.width = (elixir/10*100)+"%";

    updateHudTimeAndTrophies(performance.now());

    updateMoleAbilityUi();

    if(gameStarted) renderHand();
}

function shuffle(arr){
    for(let i = arr.length - 1; i > 0; i--){
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
}

function initHands(){
    const pool = getUnlockedPool();
    playerHand = shuffle([...pool]).slice(0, HAND_SIZE);
    aiHand = shuffle([...pool]).slice(0, HAND_SIZE);
}

// Fish is a permanent decoration in hand UI (not a card)

function drawReplacement(currentHand, usedCardId, pool){
    const inHand = new Set(currentHand);
    const options = pool.filter(id => !inHand.has(id) && id !== usedCardId);
    if(options.length === 0){
        // fallback (shouldn't happen with pool>hand)
        const fallback = pool.filter(id => !inHand.has(id));
        return fallback.length ? fallback[Math.floor(Math.random()*fallback.length)] : usedCardId;
    }
    return options[Math.floor(Math.random()*options.length)];
}

function replaceUsedCardInHand(hand, usedCardId){
    const idx = hand.indexOf(usedCardId);
    if(idx === -1) return;
    const pool = (hand === playerHand && playerDeck.length) ? playerDeck : getUnlockedPool();
    const next = drawReplacement(hand, usedCardId, pool);
    hand[idx] = next;
}

function renderDeckPicker(){
    const grid = document.getElementById("deckGrid");
    const hint = document.getElementById("deckHint");
    const startBtn = document.getElementById("deckStart");
    if(!grid || !hint || !startBtn) return;

    grid.innerHTML = "";
    const pool = getUnlockedPool();
    for(const id of pool){
        const card = cards[id];
        const btn = document.createElement("button");
        btn.innerText = `${card.emoji} ${card.name} (${card.cost})`;
        if(selectedDeck.has(id)) btn.classList.add("picked");
        btn.onclick = ()=>{
            if(selectedDeck.has(id)){
                selectedDeck.delete(id);
            } else {
                if(selectedDeck.size >= HAND_SIZE) return;
                selectedDeck.add(id);
            }
            renderDeckPicker();
        };
        grid.appendChild(btn);
    }
    hint.innerText = `Vybr√°no: ${selectedDeck.size} / ${HAND_SIZE}`;
    startBtn.disabled = selectedDeck.size !== HAND_SIZE;
}

function startGame(){
    if(selectedDeck.size !== HAND_SIZE) return;
    gameStarted = true;
    playerDeck = [...selectedDeck];
    playerHand = [...playerDeck];
    aiHand = pickAiStartHandDifferent();

    matchStartMs = performance.now();
    inSuddenDeath = false;

    const overlay = document.getElementById("deckOverlay");
    if(overlay) overlay.classList.add("hidden");
    updateHud();
}

function renderHand(){
    const ui = document.getElementById("ui");
    ui.innerHTML = "";
    for(const id of playerHand){
        const card = cards[id];
        if(!card) continue;
        const btn = document.createElement("button");
        btn.innerHTML = `${card.emoji} ${card.name}<br><small>${card.cost}</small>`;
        btn.disabled = gameOver || elixir < card.cost;
        if(selectedCard === id) btn.classList.add("selected");
        btn.onclick = ()=>selectCard(id);
        ui.appendChild(btn);
    }
}

function initTowerUi(t){
    t.element.innerHTML = "<div class='tower-value'></div><div class='tower-hpbar'><div class='tower-hpfill'></div></div>";
    t.valueEl = t.element.querySelector(".tower-value");
    t.hpFillEl = t.element.querySelector(".tower-hpfill");
    renderTower(t);
}

function renderTower(t){
    if(!t.valueEl || !t.hpFillEl) return;
    if(t.hp <= 0){
        t.valueEl.innerText = "‚ùå";
        t.hpFillEl.style.width = "0%";
        t.element.style.filter = "grayscale(1) brightness(.8)";
        return;
    }
    t.valueEl.innerText = t.hp + (t.shieldCharges && t.shieldCharges > 0 ? " üõ°Ô∏è" : "");
    t.hpFillEl.style.width = Math.max(0, (t.hp/t.maxHp*100)) + "%";
}

playerTowers.forEach(initTowerUi);
aiTowers.forEach(initTowerUi);

function selectCard(c){
    if(!playerHand.includes(c)) return;
    selectedCard = c;
    setLog("Vybr√°na karta: " + cards[c].name + " (" + cards[c].cost + ")");
    updateHud();
    hideSpellPreview();
}

arena.addEventListener("mousemove", (e)=>{
    const { x, y } = arenaCoordsFromEvent(e);
    updateSpellPreview(x, y);
});

arena.addEventListener("mouseleave", ()=>{
    hideSpellPreview();
});

arena.onclick = function(e){
    if(!selectedCard) return;
    if(!gameStarted) return;
    if(gameOver) return;
    if(!playerHand.includes(selectedCard)){
        selectedCard = null;
        updateHud();
        return;
    }
    const { x, y } = arenaCoordsFromEvent(e);
    const card = cards[selectedCard];

    hideSpellPreview();

    if(card && card.type === "spell"){
        // Spells can be cast anywhere
        const ok = castSpell(x, y, selectedCard, true);
        if(ok){
            lastPlayerUsedCardId = selectedCard;
            replaceUsedCardInHand(playerHand, selectedCard);
            selectedCard = null;
            updateHud();
        }
        return;
    }

    if(y > (ARENA_H/2)){ // pouze spodn√≠ polovina
        const ok = spawnUnit(x, y, selectedCard, true);
        if(ok){
            lastPlayerUsedCardId = selectedCard;
            replaceUsedCardInHand(playerHand, selectedCard);
            selectedCard = null;
            updateHud();
        }
    } else {
        // Krtek can be placed anywhere
        if(selectedCard === 15){
            const ok = spawnUnit(x, y, selectedCard, true);
            if(ok){
                lastPlayerUsedCardId = selectedCard;
                replaceUsedCardInHand(playerHand, selectedCard);
                selectedCard = null;
                updateHud();
                return;
            }
        }
        setLog("Jednotku m≈Ø≈æe≈° polo≈æit jen do spodn√≠ poloviny.");
    }
};

document.addEventListener("keydown", (ev)=>{
    if(!gameStarted || gameOver) return;
    if(!playerRotWall || playerRotWall.hp <= 0) return;

    const step = 15;
    if(ev.key === "ArrowLeft"){
        playerRotWall.rotDeg = (playerRotWall.rotDeg || 0) - step;
        renderUnit(playerRotWall);
        ev.preventDefault();
    } else if(ev.key === "ArrowRight"){
        playerRotWall.rotDeg = (playerRotWall.rotDeg || 0) + step;
        renderUnit(playerRotWall);
        ev.preventDefault();
    }
});

// jednotky data
const cards = {
    // Slower balance
    1:{name:"Ryt√≠≈ô", emoji:"üó°Ô∏è", hp:90, dmg:14, cost:3, speed:60, range:18, attackCdMs:900},
    2:{name:"Luƒçi≈°tnice", emoji:"üèπ", hp:65, dmg:11, cost:2, speed:68, range:120, attackCdMs:1200, projectile:true},
    3:{name:"Obr", emoji:"üóø", hp:190, dmg:22, cost:5, speed:46, range:20, attackCdMs:1350},
    5:{name:"Mega ryt√≠≈ô", emoji:"üõ°Ô∏èüí•", hp:260, dmg:0, cost:6, speed:62, range:22, attackCdMs:1000, slam:{radius:80, dmg:50}, cleaveRadius:36},
    6:{name:"Raketa", emoji:"üöÄ", cost:6, type:"spell", target:"enemy", rocket:{radius:90, dmgUnits:500, dmgTowers:100}},
    7:{name:"≈†t√≠t", emoji:"üõ°Ô∏è", cost:4, type:"spell", target:"ally", shield:{addCharges:1, pickRadius:95}},
    8:{name:"Skeleton Army", emoji:"üíÄ", cost:3, spawn:{count:6, spread:34}, unit:{name:"Kostlivec", emoji:"üíÄ", hp:10, dmg:5, speed:78, range:18, attackCdMs:980}},
    9:{name:"P.E.K.K.A", emoji:"ü§ñ‚öîÔ∏è", hp:100, maxHp:200, dmg:100, cost:7, speed:44, range:20, attackCdMs:2200},
    10:{name:"X-bow", emoji:"üèπ", hp:180, dmg:10, cost:6, speed:0, range:240, attackCdMs:650, projectile:true, decayPerSec:7},
    11:{name:"Heal Spirit", emoji:"üíöüëª", hp:1, dmg:0, cost:1, speed:92, range:0, attackCdMs:999999,
        lifetimeMs:5000,
        healer:{radius:68, pct:0.05, cdMs:950, preferDamaged:true, includeTowers:true}},
    12:{name:"Zeƒè", emoji:"", hp:200, dmg:0, cost:3, speed:0, range:0, attackCdMs:999999, decayPerSec:10}
    ,13:{name:"Zap", emoji:"‚ö°", cost:2, type:"spell", target:"enemy", zap:{radius:90, dmg:30}}
    ,14:{name:"Goblin barell", emoji:"üõ¢Ô∏èüë∫", cost:3, type:"spell", target:"enemy",
        barrel:{radius:90, count:3, spread:24, unit:{name:"Goblin", emoji:"üë∫", hp:20, dmg:10, speed:80, range:18, attackCdMs:900}}}
    ,15:{name:"Krtek", emoji:"üï≥Ô∏èüêæ", hp:50, dmg:25, cost:3, speed:72, range:18, attackCdMs:900}
};

function createUnitInstance(base, x, y, isPlayer, cardId){
    const unitEl = document.createElement("div");
    unitEl.className = "unit " + (isPlayer ? "player" : "ai");
    if(cardId === 10) unitEl.classList.add("xbow-emoji");
    if(cardId === 12) unitEl.classList.add("wall");

    let valueEl = null;
    if(cardId === 10){
        valueEl = document.createElement("div");
        valueEl.className = "unit-value";
        valueEl.innerText = String(base.hp);
        unitEl.appendChild(valueEl);
    }

    const faceEl = document.createElement("div");
    faceEl.className = "unit-face";
    faceEl.innerText = base.emoji;
    unitEl.appendChild(faceEl);
    const hpEl = document.createElement("div");
    hpEl.className = "unit-hp";
    const hpFillEl = document.createElement("div");
    hpFillEl.className = "unit-hpfill";
    hpEl.appendChild(hpFillEl);
    unitEl.appendChild(hpEl);
    arena.appendChild(unitEl);

    const data = {
        id: crypto.randomUUID ? crypto.randomUUID() : String(Math.random()).slice(2),
        cardId,
        name: base.name,
        emoji: base.emoji,
        hp: base.hp,
        maxHp: (base.maxHp ?? base.hp),
        dmg: base.dmg,
        speed: base.speed, // px/s
        range: base.range,
        attackCdMs: base.attackCdMs,
        projectile: !!base.projectile,
        isPlayer,
        x: clamp(x, 20, ARENA_W-20),
        y: clamp(y, 20, ARENA_H-20),
        lastAttackMs: 0,
        lastHealMs: 0,
        lastLeapMs: 0,
        leapsDone: 0,
        spawnedAtMs: performance.now(),
        frozenUntilMs: 0,
        lifeMs: (base.lifetimeMs ?? null),
        rotDeg: 0,
        element: unitEl,
        hpFillEl,
        faceEl,
        facingRad: 0,
        valueEl
    };

    if(isPlayer) playerUnits.push(data); else aiUnits.push(data);
    renderUnit(data);

    // MR: don't allow an instant jump right after placement
    if(cardId === 5){
        data.lastLeapMs = data.spawnedAtMs;
    }

    if(isPlayer && cardId === 12){
        playerRotWall = data;
    }

    if(isPlayer && cardId === 15){
        playerMole = data;
        updateMoleAbilityUi();
    }
    return data;
}

function spawnUnit(x,y,cardId,isPlayer){
    const base = cards[cardId];
    if(!base) return false;
    if(base.type === "spell") return false;
    const cost = base.cost;

    if(isPlayer){
        if(elixir < cost){
            setLog("Nem√°≈° dost elix√≠ru.");
            return false;
        }
        elixir -= cost;
    } else {
        if(aiElixir < cost) return false;
        aiElixir -= cost;
    }

    // Skeleton Army: spawn 6 skeletons around click point
    if(cardId === 8 && base.spawn && base.unit){
        const n = base.spawn.count;
        const spread = base.spawn.spread;
        for(let i=0;i<n;i++){
            const ang = (Math.PI*2) * (i/n) + (Math.random()*0.6);
            const r = (spread*0.35) + Math.random()*spread;
            const sx = x + Math.cos(ang)*r;
            const sy = y + Math.sin(ang)*r;
            createUnitInstance(base.unit, sx, sy, isPlayer, 8);
        }
        return true;
    }

    const data = createUnitInstance(base, x, y, isPlayer, cardId);

    // special: Mega knight landing AoE
    if(cardId === 5 && base.slam){
        // landing VFX only (MR's damage comes from jumps)
        spawnExplosion(data.x, data.y, "slam");
    }

    return true;
}

function spawnExplosion(x, y, kind){
    const el = document.createElement("div");
    el.className = "explosion" + (kind ? (" " + kind) : "");
    el.style.left = x + "px";
    el.style.top = y + "px";
    arena.appendChild(el);
    setTimeout(()=>{ try{ el.remove(); } catch(e){} }, 650);
}

function castSpell(x, y, cardId, isPlayer){
    const base = cards[cardId];
    if(!base || base.type !== "spell") return false;

    const cost = base.cost;
    if(isPlayer){
        if(elixir < cost){
            setLog("Nem√°≈° dost elix√≠ru.");
            return false;
        }
        elixir -= cost;
    } else {
        if(aiElixir < cost) return false;
        aiElixir -= cost;
    }


    if(cardId === 6 && base.rocket){
        const tx = clamp(x, 20, ARENA_W-20);
        const ty = clamp(y, 20, ARENA_H-20);
        spawnExplosion(tx, ty, "rocket");

        const enemiesUnits = isPlayer ? aiUnits : playerUnits;
        const enemiesTowers = isPlayer ? aiTowers : playerTowers;
        for(const u of enemiesUnits){
            if(u.hp <= 0) continue;
            if(Math.hypot(u.x - tx, u.y - ty) <= base.rocket.radius){
                applyDamage(u, base.rocket.dmgUnits);
            }
        }
        for(const t of enemiesTowers){
            if(t.hp <= 0) continue;
            if(Math.hypot(t.x - tx, t.y - ty) <= base.rocket.radius){
                applyDamage(t, base.rocket.dmgTowers);
            }
        }
        setLog((isPlayer?"Ty":"AI") + " pou≈æil(a) raketu!");
        return true;
    }

    if(cardId === 13 && base.zap){
        const tx = clamp(x, 20, ARENA_W-20);
        const ty = clamp(y, 20, ARENA_H-20);
        spawnExplosion(tx, ty, "rocket");

        const enemiesUnits = isPlayer ? aiUnits : playerUnits;
        const enemiesTowers = isPlayer ? aiTowers : playerTowers;
        for(const u of enemiesUnits){
            if(u.hp <= 0) continue;
            if(Math.hypot(u.x - tx, u.y - ty) <= base.zap.radius){
                applyDamage(u, base.zap.dmg);
            }
        }
        for(const t of enemiesTowers){
            if(t.hp <= 0) continue;
            if(Math.hypot(t.x - tx, t.y - ty) <= base.zap.radius){
                applyDamage(t, base.zap.dmg);
            }
        }
        setLog((isPlayer?"Ty":"AI") + " pou≈æil(a) zap!");
        return true;
    }

    if(cardId === 14 && base.barrel){
        const tx = clamp(x, 20, ARENA_W-20);
        const ty = clamp(y, 20, ARENA_H-20);
        spawnExplosion(tx, ty, "rocket");

        const spawnX = tx;
        const spawnY = ty;
        const n = base.barrel.count || 3;
        const spread = base.barrel.spread || 22;
        for(let i=0;i<n;i++){
            const ang = (Math.PI*2) * (i/n) + (Math.random()*0.6);
            const r = (spread*0.35) + Math.random()*spread;
            const sx = spawnX + Math.cos(ang)*r;
            const sy = spawnY + Math.sin(ang)*r;
            createUnitInstance(base.barrel.unit, sx, sy, isPlayer, 14);
        }

        setLog((isPlayer?"Ty":"AI") + " pou≈æil(a) Goblin barell!");
        return true;
    }

    if(cardId === 7 && base.shield){
        // choose nearest allied tower to click
        const towers = isPlayer ? playerTowers : aiTowers;
        let best = null;
        let bestD = Infinity;
        for(const t of towers){
            if(t.hp <= 0) continue;
            const d = Math.hypot(t.x - x, t.y - y);
            if(d < bestD){ bestD = d; best = t; }
        }

        if(!best || bestD > base.shield.pickRadius){
            setLog("Klikni bl√≠≈æ k vƒõ≈æi, na kterou chce≈° d√°t ≈°t√≠t.");
            return false;
        }

        best.shieldCharges = (best.shieldCharges || 0) + base.shield.addCharges;
        renderTower(best);
        spawnExplosion(best.x, best.y, "rocket");
        setLog((isPlayer?"Ty":"AI") + " dal(a) ≈°t√≠t na vƒõ≈æ!");
        return true;
    }

    return false;
}

function findTarget(unit){
    const enemies = unit.isPlayer ? aiUnits : playerUnits;
    const towers = unit.isPlayer ? aiTowers : playerTowers;

    // MR (Mega ryt√≠≈ô): targets only enemy units (never towers)
    if(unit.cardId === 5){
        let best = null;
        let bestD = Infinity;
        for(const e of enemies){
            if(e.hp <= 0) continue;
            if(e.cardId === 12) continue;
            const d = Math.hypot(unit.x - e.x, unit.y - e.y);
            if(d < bestD){ bestD = d; best = e; }
        }
        return best;
    }

    // Obr jde jen na vƒõ≈æe
    if(unit.cardId === 3){
        // ...a tak√© na X-bow (bere se jako budova)
        let best = null;
        let bestD = Infinity;
        for(const t of towers){
            if(t.hp <= 0) continue;
            const d = Math.hypot(unit.x - t.x, unit.y - t.y);
            if(d < bestD){ bestD = d; best = t; }
        }
        for(const e of enemies){
            if(e.hp <= 0) continue;
            if(e.cardId !== 10) continue;
            const d = Math.hypot(unit.x - e.x, unit.y - e.y);
            if(d < bestD){ bestD = d; best = e; }
        }
        return best;
    }

    // Luƒçi≈°tnice st≈ô√≠l√≠ jen na jednotky (vƒõ≈æe ignoruje jako c√≠l pro √∫tok)
    if(unit.cardId === 2){
        let best = null;
        let bestD = Infinity;
        for(const e of enemies){
            if(e.hp <= 0) continue;
            if(e.cardId === 12) continue;
            const d = Math.hypot(unit.x - e.x, unit.y - e.y);
            if(d < bestD){ bestD = d; best = e; }
        }
        // kdy≈æ nejsou nep≈ô√°telsk√© jednotky, luƒçi≈°tnice nejde na vƒõ≈æe
        return best;
    }

    // Ostatn√≠: nejbli≈æ≈°√≠ c√≠l (jednotka nebo vƒõ≈æ)
    let best = null;
    let bestD = Infinity;
    for(const e of enemies){
        if(e.hp <= 0) continue;
        if(e.cardId === 12) continue;
        const d = Math.hypot(unit.x - e.x, unit.y - e.y);
        if(d < bestD){ bestD = d; best = e; }
    }
    for(const t of towers){
        if(t.hp <= 0) continue;
        const d = Math.hypot(unit.x - t.x, unit.y - t.y);
        if(d < bestD){ bestD = d; best = t; }
    }
    return best;
}

function clamp(v, a, b){
    return Math.max(a, Math.min(b, v));
}

function renderUnit(u){
    u.element.style.left = u.x + "px";
    u.element.style.top = u.y + "px";

    const nowMs = performance.now();
    if(u.frozenUntilMs && nowMs < u.frozenUntilMs){
        u.element.classList.add("frozen");
    } else {
        u.element.classList.remove("frozen");
    }

    if(u.cardId === 12){
        const deg = (u.rotDeg || 0);
        u.element.style.transform = `translate(-50%, -50%) rotate(${deg}deg)`;
    } else {
        // keep default CSS transform (translate) for regular units
        u.element.style.transform = "";
    }
    u.hpFillEl.style.width = Math.max(0, (u.hp/u.maxHp*100)) + "%";
    if(u.cardId === 10 && u.valueEl){
        u.valueEl.innerText = String(Math.ceil(u.hp));
    }
    // Rotate only the X-bow emoji to face target
    if(u.cardId === 10 && u.faceEl){
        const deg = (u.facingRad || 0) * 180 / Math.PI;
        u.faceEl.style.transform = `rotate(${deg}deg)`;
    } else if(u.faceEl){
        u.faceEl.style.transform = "";
    }
    if(u.hp <= 0){
        u.element.style.filter = "grayscale(1) brightness(.85)";
        u.element.style.opacity = "0";
    }
}

function removeDead(){
    const keepAlive = (u)=>u.hp>0;
    const removeUnit = (u)=>{ try{ u.element.remove(); } catch(e){} };
    playerUnits.filter(u=>u.hp<=0).forEach(removeUnit);
    aiUnits.filter(u=>u.hp<=0).forEach(removeUnit);
    playerUnits = playerUnits.filter(keepAlive);
    aiUnits = aiUnits.filter(keepAlive);
}

function nearestBridgeX(x){
    return BRIDGES_X.reduce((best, bx)=> Math.abs(bx-x) < Math.abs(best-x) ? bx : best, BRIDGES_X[0]);
}

function applyDamage(target, amount, opts = {}){
    if(!target || target.hp <= 0) return;

    // Wall (Zeƒè) is immune to attacks (only decays over time)
    if(!target.isTower && target.cardId === 12) return;

    // Tower shield: absorbs ALL incoming damage once and redirects it to a random enemy tower
    if(target.isTower && !opts.skipShield && amount > 0 && target.shieldCharges && target.shieldCharges > 0){
        target.shieldCharges -= 1;
        renderTower(target);
        spawnExplosion(target.x, target.y, "rocket");

        const enemyTowers = target.team === "player" ? aiTowers : playerTowers;
        const alive = enemyTowers.filter(t=>t.hp>0);
        if(alive.length > 0){
            const redirect = alive[Math.floor(Math.random()*alive.length)];
            applyDamage(redirect, amount, { skipShield:true });
        }
        return;
    }

    const prevHp = target.hp;
    target.hp = Math.max(0, target.hp - amount);
    if(target.isTower){
        renderTower(target);
    } else {
        renderUnit(target);
    }

    // P.E.K.K.A heal on kill (only when it lands the killing blow)
    if(prevHp > 0 && target.hp === 0 && opts.attacker && !opts.attacker.isTower && opts.attacker.cardId === 9){
        opts.attacker.hp = Math.min(opts.attacker.maxHp, opts.attacker.hp + 25);
        renderUnit(opts.attacker);
    }
}

function applyHeal(target, amount){
    if(!target || target.hp <= 0) return;
    if(amount <= 0) return;
    const prev = target.hp;
    target.hp = Math.min(target.maxHp ?? target.hp, target.hp + amount);
    if(target.hp === prev) return;
    if(target.isTower){
        renderTower(target);
    } else {
        renderUnit(target);
    }
}

function weightedPick(options){
    // options: [{id, w}]
    let sum = 0;
    for(const o of options) sum += o.w;
    let r = Math.random() * sum;
    for(const o of options){
        r -= o.w;
        if(r <= 0) return o.id;
    }
    return options[options.length-1].id;
}

function spawnProjectile(x, y, tx, ty, dmg, team, kind){
    const el = document.createElement("div");
    el.className = "projectile" + (kind ? (" " + kind) : "");
    arena.appendChild(el);
    const speed = 340; // px/s (slower feel)
    const dx = tx - x;
    const dy = ty - y;
    const d = Math.max(1, Math.hypot(dx, dy));
    const vx = dx/d*speed;
    const vy = dy/d*speed;
    const p = {x, y, vx, vy, dmg, team, element: el, lifeMs: 1200, speed};
    projectiles.push(p);
    el.style.left = x + "px";
    el.style.top = y + "px";
}

function spawnHomingProjectile(x, y, target, dmg, team, kind){
    if(!target) return;
    const el = document.createElement("div");
    el.className = "projectile" + (kind ? (" " + kind) : "");
    arena.appendChild(el);
    const speed = 340;
    const dx = target.x - x;
    const dy = target.y - y;
    const d = Math.max(1, Math.hypot(dx, dy));
    const vx = dx/d*speed;
    const vy = dy/d*speed;
    const p = {x, y, vx, vy, dmg, team, element: el, lifeMs: 1200, speed, homing:true, target};
    projectiles.push(p);
    el.style.left = x + "px";
    el.style.top = y + "px";
}

function clearBattlefield(){
    playerUnits.forEach(u=>{ try{ u.element.remove(); } catch(e){} });
    aiUnits.forEach(u=>{ try{ u.element.remove(); } catch(e){} });
    playerUnits = [];
    aiUnits = [];
    projectiles.forEach(p=>{ try{ p.element.remove(); } catch(e){} });
    projectiles = [];
}

function updateProjectiles(dtMs){
    const dt = dtMs / 1000;
    for(const p of projectiles){
        if(p.homing && p.target && p.target.hp > 0){
            const dx = p.target.x - p.x;
            const dy = p.target.y - p.y;
            const d = Math.max(1, Math.hypot(dx, dy));
            const speed = p.speed || 340;
            p.vx = dx/d*speed;
            p.vy = dy/d*speed;
        }
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.lifeMs -= dtMs;
        p.element.style.left = p.x + "px";
        p.element.style.top = p.y + "px";
    }

    // collisions: very simple (hit enemy unit OR tower within radius)
    for(const p of projectiles){
        if(p.lifeMs <= 0) continue;
        const enemies = p.team === "player" ? aiUnits : playerUnits;
        const enemyTowers = p.team === "player" ? aiTowers : playerTowers;
        let hit = null;
        for(const e of enemies){
            if(e.hp<=0) continue;
            if(e.cardId === 12) continue;
            if(Math.hypot(p.x - e.x, p.y - e.y) < 18){ hit = e; break; }
        }
        if(!hit){
            for(const t of enemyTowers){
                if(t.hp<=0) continue;
                if(Math.hypot(p.x - t.x, p.y - t.y) < 46){ hit = t; break; }
            }
        }
        if(hit){
            applyDamage(hit, p.dmg);
            p.lifeMs = 0;
        }
    }

    projectiles.filter(p=>p.lifeMs<=0).forEach(p=>{ try{ p.element.remove(); } catch(e){} });
    projectiles = projectiles.filter(p=>p.lifeMs>0);
}

function unitMoveVector(unit, target){
    // Jednotky NESM√ç chodit p≈ôes vodu: p≈ôes ≈ôeku jen po mostƒõ.
    // ≈òe≈°en√≠: waypointy (1) zarovnat se na X mostu na sv√© stranƒõ, (2) doj√≠t k okraji ≈ôeky,
    // (3) p≈ôej√≠t vertik√°lnƒõ po mostƒõ, (4) pokraƒçovat k c√≠li.
    const riverTop = RIVER_Y;
    const riverBottom = RIVER_Y + RIVER_H;
    const inRiver = (y)=> y >= riverTop && y <= riverBottom;
    const needsCross = unit.isPlayer
        ? (unit.y > riverBottom && target.y < riverTop)
        : (unit.y < riverTop && target.y > riverBottom);

    let tx = target.x;
    let ty = target.y;

    if(needsCross || inRiver(unit.y)){
        const bx = nearestBridgeX(unit.x);
        const ALIGN_EPS = 6;
        const EDGE_PAD = 8;

        // 1) nejd≈ô√≠v zarovnat X na most (horizont√°lnƒõ), dokud nejsme v ≈ôece
        if(!inRiver(unit.y) && Math.abs(unit.x - bx) > ALIGN_EPS){
            tx = bx;
            ty = unit.y;
        } else {
            if(unit.isPlayer){
                // hr√°ƒç jde NAHORU (z doln√≠ p≈Ølky do horn√≠)
                if(unit.y > riverBottom + EDGE_PAD){
                    // 2) doj√≠t k doln√≠mu okraji ≈ôeky na X mostu
                    tx = bx;
                    ty = riverBottom + EDGE_PAD;
                } else if(unit.y > riverTop - EDGE_PAD){
                    // 3) p≈ôej√≠t ≈ôeku vertik√°lnƒõ po mostƒõ
                    tx = bx;
                    ty = riverTop - EDGE_PAD;
                } else {
                    // 4) jsme nad ≈ôekou
                    tx = target.x;
                    ty = target.y;
                }
            } else {
                // AI jde DOL≈Æ (z horn√≠ p≈Ølky do doln√≠)
                if(unit.y < riverTop - EDGE_PAD){
                    tx = bx;
                    ty = riverTop - EDGE_PAD;
                } else if(unit.y < riverBottom + EDGE_PAD){
                    tx = bx;
                    ty = riverBottom + EDGE_PAD;
                } else {
                    tx = target.x;
                    ty = target.y;
                }
            }

            // pokud jsme v ≈ôece a nejsme na X mostu, dot√°hni X na most
            if(inRiver(unit.y) && Math.abs(unit.x - bx) > ALIGN_EPS){
                tx = bx;
                ty = unit.y;
            }
        }
    }

    const dx = tx - unit.x;
    const dy = ty - unit.y;
    const dist = Math.max(1, Math.hypot(dx, dy));
    return {dx, dy, dist};
}

function updateUnits(nowMs, dtMs){
    const dt = dtMs / 1000;
    const all = playerUnits.concat(aiUnits);
    for(const u of all){
        if(u.hp <= 0) continue;

        // timed lifetime (e.g., Heal Spirit)
        if(u.lifeMs != null){
            u.lifeMs -= dtMs;
            if(u.lifeMs <= 0){
                u.hp = 0;
                renderUnit(u);
                continue;
            }
        }

        // Self-decay over time (e.g., X-bow, Wall)
        const decay = cards[u.cardId] && cards[u.cardId].decayPerSec;
        if(decay){
            u.hp = Math.max(0, u.hp - decay * dt);
            if(u.hp <= 0){
                renderUnit(u);
                continue;
            }
            // keep decay visible even if it currently has no target
            renderUnit(u);
        }
        // Heal Spirit: heals nearby allies by 5% while alive
        if(u.cardId === 11 && cards[11] && cards[11].healer){
            const healer = cards[11].healer;
            const allyUnits = u.isPlayer ? playerUnits : aiUnits;
            const allyTowers = u.isPlayer ? playerTowers : aiTowers;

            let best = null;
            let bestScore = -1;
            // prefer most damaged (ratio), tie-break by distance
            for(const a of allyUnits){
                if(a.hp <= 0) continue;
                if(a === u) continue;
                if(a.hp >= a.maxHp) continue;
                const dmgRatio = (a.maxHp - a.hp) / a.maxHp;
                const d = Math.hypot(u.x - a.x, u.y - a.y);
                const score = dmgRatio * 1000 - d;
                if(score > bestScore){ bestScore = score; best = a; }
            }
            if(healer.includeTowers){
                for(const t of allyTowers){
                    if(t.hp <= 0) continue;
                    if(t.hp >= t.maxHp) continue;
                    const dmgRatio = (t.maxHp - t.hp) / t.maxHp;
                    const d = Math.hypot(u.x - t.x, u.y - t.y);
                    const score = dmgRatio * 1000 - d;
                    if(score > bestScore){ bestScore = score; best = t; }
                }
            }
            // if nobody is damaged, just hang near closest allied middle tower
            if(!best){
                const t = allyTowers[1] || allyTowers[0];
                if(t && t.hp > 0) best = t;
            }

            if(best){
                const d = Math.hypot(u.x - best.x, u.y - best.y);
                if(d <= healer.radius && nowMs - (u.lastHealMs || 0) >= healer.cdMs){
                    const amount = (best.maxHp ?? best.hp) * healer.pct;
                    applyHeal(best, amount);
                    u.lastHealMs = nowMs;
                }
                if(u.speed > 0 && d > healer.radius * 0.75){
                    const dx = best.x - u.x;
                    const dy = best.y - u.y;
                    const dist = Math.max(1, Math.hypot(dx, dy));
                    const step = u.speed * dt;
                    u.x += (dx/dist) * step;
                    u.y += (dy/dist) * step;
                    u.x = clamp(u.x, 18, ARENA_W-18);
                    u.y = clamp(u.y, 18, ARENA_H-18);
                }
            }
            renderUnit(u);
            continue;
        }

        // Frozen units can't move or attack
        if(u.frozenUntilMs && nowMs < u.frozenUntilMs){
            renderUnit(u);
            continue;
        }

        let target = findTarget(u);
        // Safety: MR should never go for towers
        if(u.cardId === 5 && target && target.isTower) target = null;
        // MR: if there are no enemy units, go fully back and wait
        if(!target && u.cardId === 5){
            const backY = u.isPlayer ? (ARENA_H - 32) : 32;
            const dy = backY - u.y;
            const dist = Math.abs(dy);
            if(dist > 2){
                const step = u.speed * dt;
                u.y = clamp(u.y + Math.sign(dy) * Math.min(step, dist), 18, ARENA_H-18);
                renderUnit(u);
            }
            continue;
        }
        if(!target) continue;

        if(u.cardId === 10){
            u.facingRad = Math.atan2(target.y - u.y, target.x - u.x);
        }

        const dToTarget = Math.hypot(u.x - target.x, u.y - target.y);
        const inRange = dToTarget <= u.range;
        const canAttackTarget = !(u.cardId === 2 && target.isTower) && !(u.cardId === 5 && target.isTower);
        if(inRange && canAttackTarget){
            if(nowMs - u.lastAttackMs >= u.attackCdMs){
                u.lastAttackMs = nowMs;
                if(u.projectile){
                    const kind = u.projectileKind || (cards[u.cardId] && cards[u.cardId].projectileKind);
                    if(u.cardId === 2 || u.cardId === 10){
                        spawnHomingProjectile(u.x, u.y, target, u.dmg, u.isPlayer ? "player" : "ai", kind);
                    } else {
                        spawnProjectile(u.x, u.y, target.x, target.y, u.dmg, u.isPlayer ? "player" : "ai", kind);
                    }
                } else {
                    // Mega knight cleave: hit multiple enemies in a small area
                    if(u.cardId === 5 && cards[5].cleaveRadius && !target.isTower){
                        const radius = cards[5].cleaveRadius;
                        const enemies = u.isPlayer ? aiUnits : playerUnits;
                        for(const e of enemies){
                            if(e.hp<=0) continue;
                            if(Math.hypot(e.x - target.x, e.y - target.y) <= radius){
                                // MR: normal hit does 0 dmg, but knocks + freezes
                                const knockDist = 240; // ~2x "d√©lka mostu"
                                const freezeMs = 5000;
                                const dir = u.isPlayer ? -1 : 1;
                                e.y = clamp(e.y + dir * knockDist, 18, ARENA_H-18);
                                e.frozenUntilMs = Math.max(e.frozenUntilMs || 0, nowMs + freezeMs);
                                renderUnit(e);
                            }
                        }
                    } else {
                        if(u.cardId === 5 && target && !target.isTower && target.hp > 0 && target.cardId !== 12){
                            const knockDist = 240; // ~2x "d√©lka mostu"
                            const freezeMs = 5000;
                            const dir = u.isPlayer ? -1 : 1;
                            target.y = clamp(target.y + dir * knockDist, 18, ARENA_H-18);
                            target.frozenUntilMs = Math.max(target.frozenUntilMs || 0, nowMs + freezeMs);
                            renderUnit(target);
                        } else {
                            applyDamage(target, u.dmg, { attacker: u });
                        }
                    }
                }
            }
        } else {
            // MR: doesn't walk. It jumps to the nearest enemy unit
            // and deals the same AoE slam damage as on spawn.
            if(u.cardId === 5 && cards[5] && cards[5].slam){
                const leapCdMs = 4500;
                const maxLeaps = 4;
                const initialDelayMs = 2000;
                if(
                    (u.leapsDone || 0) < maxLeaps &&
                    nowMs - (u.spawnedAtMs || 0) >= initialDelayMs &&
                    nowMs - (u.lastLeapMs || 0) >= leapCdMs
                ){
                    const enemies = u.isPlayer ? aiUnits : playerUnits;
                    let best = null;
                    let bestD = Infinity;
                    for(const e of enemies){
                        if(e.hp <= 0) continue;
                        // ignore walls as leap targets
                        if(e.cardId === 12) continue;
                        const d = Math.hypot(u.x - e.x, u.y - e.y);
                        if(d < bestD){ bestD = d; best = e; }
                    }
                    if(best){
                        u.lastLeapMs = nowMs;
                        u.leapsDone = (u.leapsDone || 0) + 1;
                        u.x = clamp(best.x, 18, ARENA_W-18);
                        u.y = clamp(best.y, 18, ARENA_H-18);

                        spawnExplosion(u.x, u.y, "slam");
                        const radius = cards[5].slam.radius;
                        const dmg = cards[5].slam.dmg;
                        for(const e of enemies){
                            if(e.hp <= 0) continue;
                            if(Math.hypot(e.x - u.x, e.y - u.y) <= radius){
                                applyDamage(e, dmg);
                            }
                        }
                    }
                }
            } else {
                // buildings (e.g., X-bow) don't move
                if(u.speed > 0){
                    const vec = unitMoveVector(u, target);
                    const step = u.speed * dt;
                    let nx = u.x + (vec.dx/vec.dist) * step;
                    let ny = u.y + (vec.dy/vec.dist) * step;
                    nx = clamp(nx, 18, ARENA_W-18);
                    ny = clamp(ny, 18, ARENA_H-18);

                    // Wall rule: enemies can't pass through, allies can.
                    // Implemented as collision against enemy walls only.
                    const enemyWalls = u.isPlayer ? aiUnits : playerUnits;
                    const UNIT_R = 22;
                    const WALL_HW = 44; // 88px / 2
                    const WALL_HH = 6;  // 12px / 2
                    let blocked = false;
                    for(const w of enemyWalls){
                        if(w.hp <= 0) continue;
                        if(w.cardId !== 12) continue;
                        const ang = ((w.rotDeg || 0) * Math.PI) / 180;
                        const dx = nx - w.x;
                        const dy = ny - w.y;
                        const ca = Math.cos(-ang);
                        const sa = Math.sin(-ang);
                        const lx = dx * ca - dy * sa;
                        const ly = dx * sa + dy * ca;
                        if(Math.abs(lx) <= (WALL_HW + UNIT_R) && Math.abs(ly) <= (WALL_HH + UNIT_R)){
                            blocked = true;
                            break;
                        }
                    }

                    if(!blocked){
                        u.x = nx;
                        u.y = ny;
                    }
                }
            }
        }
        renderUnit(u);
    }
}

function pickTowerTarget(tower){
    const enemies = tower.team === "player" ? aiUnits : playerUnits;
    // vƒõ≈æ si hl√≠d√° hlavnƒõ svou polovinu, ale kdy≈æ nic nen√≠, bere nejbli≈æ≈°√≠
    const halfOk = (u)=> tower.team === "player" ? u.y >= (ARENA_H/2 - 10) : u.y <= (ARENA_H/2 + 10);
    let candidates = enemies.filter(u=>u.hp>0 && u.cardId !== 12 && halfOk(u));
    if(candidates.length === 0) candidates = enemies.filter(u=>u.hp>0 && u.cardId !== 12);
    let best = null;
    let bestD = Infinity;
    for(const u of candidates){
        const d = Math.hypot(tower.x - u.x, tower.y - u.y);
        if(d < bestD){ bestD = d; best = u; }
    }
    return {unit: best, dist: bestD};
}

function updateTowers(nowMs){
    const towers = playerTowers.concat(aiTowers);
    // Towers should reach only a bit before the bridge
    const range = 140;
    const archerCdMs = (cards[2] && cards[2].attackCdMs) ? cards[2].attackCdMs : 1200;
    const archerDmg = (cards[2] && cards[2].dmg) ? cards[2].dmg : 10;
    const cannonCdMs = archerCdMs + 500;
    const cannonDmg = 50;
    for(const t of towers){
        if(t.hp<=0) continue;
        const picked = pickTowerTarget(t);
        if(!picked.unit) continue;
        if(picked.dist > range) continue;

        const isMiddle = t.maxHp >= 500;
        const shotCdMs = isMiddle ? cannonCdMs : archerCdMs;
        const dmg = isMiddle ? cannonDmg : archerDmg;
        const kind = isMiddle ? "stone" : "arrow";

        if(nowMs - t.lastShotMs < shotCdMs) continue;
        t.lastShotMs = nowMs;
        spawnHomingProjectile(t.x, t.y, picked.unit, dmg, t.team, kind);
    }
}

function resetTowers(){
    const towers = playerTowers.concat(aiTowers);
    for(const t of towers){
        t.hp = t.maxHp;
        t.shieldCharges = 0;
        t.lastShotMs = 0;
        if(t.element) t.element.style.filter = "";
        renderTower(t);
    }
}

function resetGame(keepSameDeck){
    clearBattlefield();
    resetTowers();

    playerRotWall = null;
    playerMole = null;
    moleCooldownUntilMs = 0;

    elixir = 5;
    aiElixir = 5;
    selectedCard = null;
    hideSpellPreview();
    lastAiSpawnMs = 0;
    lastAiUnitCardId = null;
    lastTickMs = performance.now();
    gameOver = false;
    matchStartMs = 0;
    inSuddenDeath = false;

    if(endPanelEl){
        endPanelEl.classList.add("hidden");
        endPanelEl.dataset.mode = "";
        endPanelEl.innerHTML = "";
    }

    endOverlayEl.classList.add("hidden");

    if(keepSameDeck && playerDeck && playerDeck.length === HAND_SIZE){
        gameStarted = true;
        playerHand = [...playerDeck];
        aiHand = pickAiStartHandDifferent();
        matchStartMs = performance.now();
        inSuddenDeath = false;
        const overlay = document.getElementById("deckOverlay");
        if(overlay) overlay.classList.add("hidden");
        updateHud();
        setLog("Hraje≈° se stejn√Ωm bal√≠ƒçkem.");
        return;
    }

    // back to deck picker
    gameStarted = false;
    playerDeck = [];
    selectedDeck = new Set();
    playerHand = [];
    aiHand = [];
    const ui = document.getElementById("ui");
    if(ui) ui.innerHTML = "";
    const overlay = document.getElementById("deckOverlay");
    if(overlay) overlay.classList.remove("hidden");
    renderDeckPicker();
    updateHud();
    setLog("Vyber 4 karty pro novou hru.");
}

function resetGameRandom(){
    clearBattlefield();
    resetTowers();

    playerRotWall = null;
    playerMole = null;
    moleCooldownUntilMs = 0;

    elixir = 5;
    aiElixir = 5;
    selectedCard = null;
    hideSpellPreview();
    lastAiSpawnMs = 0;
    lastAiUnitCardId = null;
    lastTickMs = performance.now();
    gameOver = false;
    matchStartMs = 0;
    inSuddenDeath = false;

    if(endPanelEl){
        endPanelEl.classList.add("hidden");
        endPanelEl.dataset.mode = "";
        endPanelEl.innerHTML = "";
    }

    endOverlayEl.classList.add("hidden");

    // start immediately with 4 random cards
    gameStarted = true;
    const pool = getUnlockedPool();
    playerDeck = shuffle([...pool]).slice(0, HAND_SIZE);
    playerHand = [...playerDeck];
    selectedDeck = new Set(playerDeck);
    aiHand = pickAiStartHandDifferent();
    matchStartMs = performance.now();
    inSuddenDeath = false;
    const overlay = document.getElementById("deckOverlay");
    if(overlay) overlay.classList.add("hidden");
    updateHud();
    setLog("Hraje≈° s n√°hodn√Ωmi kartami.");
}

function endMatch(playerWon, reasonMsg){
    if(gameOver) return;
    gameOver = true;
    selectedCard = null;

    // freeze match state
    inSuddenDeath = false;
    matchStartMs = 0;

    const remaining = aliveTowerCount("player");
    const delta = trophyDelta(playerWon, remaining);
    trophies += delta;
    saveTrophies();
    pushLeaderboardEntry();

    updateHud();
    clearBattlefield();
    endTextEl.innerText = playerWon ? "Vyhr√°l jsi!" : "Prohr√°l jsi!";
    if(endPanelEl){
        endPanelEl.classList.add("hidden");
        endPanelEl.dataset.mode = "";
        endPanelEl.innerHTML = "";
    }
    endOverlayEl.classList.remove("hidden");
    setLog(`${reasonMsg} (${delta>=0?"+":""}${delta}üèÜ)`);
}

function checkGameOver(nowMs){
    if(gameOver) return;

    // Immediate win/loss if middle tower is destroyed
    const pMid = middleTowerAlive("player");
    const aMid = middleTowerAlive("ai");
    if(!pMid || !aMid){
        if(!pMid && !aMid){
            // Rare simultaneous: decide by remaining towers
            const pc = aliveTowerCount("player");
            const ac = aliveTowerCount("ai");
            if(pc !== ac) return endMatch(pc > ac, "Konec ‚Äì padly prost≈ôedn√≠ vƒõ≈æe");
            // still tied, treat as loss (simplest)
            return endMatch(false, "Konec ‚Äì padly prost≈ôedn√≠ vƒõ≈æe");
        }
        return endMatch(!!pMid && !aMid, "Konec ‚Äì padla prost≈ôedn√≠ vƒõ≈æ");
    }

    // Time limit -> tower count
    const timeLeft = getTimeLeftMs(nowMs);
    if(timeLeft <= 0 && !inSuddenDeath){
        const pc = aliveTowerCount("player");
        const ac = aliveTowerCount("ai");
        if(pc !== ac){
            return endMatch(pc > ac, "Konec ƒçasu");
        }
        inSuddenDeath = true;
        setLog("Sudden death!");
    }

    if(inSuddenDeath){
        const pc = aliveTowerCount("player");
        const ac = aliveTowerCount("ai");
        if(pc !== ac){
            return endMatch(pc > ac, "Sudden death ‚Äì padla vƒõ≈æ");
        }
    }
}

if(endSameBtn) endSameBtn.onclick = ()=>resetGame(true);
if(endNewBtn) endNewBtn.onclick = ()=>resetGame(false);
if(endRandomBtn) endRandomBtn.onclick = ()=>resetGameRandom();

function aiThink(nowMs){
    if(gameOver) return;
    if(nowMs - lastAiSpawnMs < 950) return;
    if(Math.random() < 0.55) return;

    // obƒças pou≈æij raketu na shluk jednotek / vƒõ≈æ (jen pokud je v ruce)
    if(aiHand.includes(6) && cards[6] && aiElixir >= cards[6].cost && Math.random() < 0.20){
        const enemyUnits = playerUnits.filter(u=>u.hp>0);
        const enemyTowers = playerTowers.filter(t=>t.hp>0);

        // preferuj shluk jednotek
        let best = null;
        let bestScore = 0;
        for(const u of enemyUnits){
            const score = enemyUnits.reduce((acc, v)=> acc + (Math.hypot(v.x-u.x, v.y-u.y) <= cards[6].rocket.radius ? 1 : 0), 0);
            if(score > bestScore){ bestScore = score; best = {x:u.x, y:u.y}; }
        }

        if(best && bestScore >= 2){
            const ok = castSpell(best.x, best.y, 6, false);
            if(ok){
                lastAiSpawnMs = nowMs;
                lastAiUsedCardId = 6;
                replaceUsedCardInHand(aiHand, 6);
            }
            return;
        }

        // jinak tref vƒõ≈æ
        if(enemyTowers.length>0){
            enemyTowers.sort((a,b)=>a.hp-b.hp);
            const t = enemyTowers[0];
            const ok = castSpell(t.x, t.y, 6, false);
            if(ok){
                lastAiSpawnMs = nowMs;
                lastAiUsedCardId = 6;
                replaceUsedCardInHand(aiHand, 6);
            }
            return;
        }
    }

    // obƒças pou≈æij zap na shluk jednotek / vƒõ≈æ (jen pokud je v ruce)
    if(aiHand.includes(13) && cards[13] && aiElixir >= cards[13].cost && Math.random() < 0.26){
        const enemyUnits = playerUnits.filter(u=>u.hp>0);
        const enemyTowers = playerTowers.filter(t=>t.hp>0);

        let best = null;
        let bestScore = 0;
        for(const u of enemyUnits){
            const score = enemyUnits.reduce((acc, v)=> acc + (Math.hypot(v.x-u.x, v.y-u.y) <= cards[13].zap.radius ? 1 : 0), 0);
            if(score > bestScore){ bestScore = score; best = {x:u.x, y:u.y}; }
        }

        if(best && bestScore >= 2){
            const ok = castSpell(best.x, best.y, 13, false);
            if(ok){
                lastAiSpawnMs = nowMs;
                lastAiUsedCardId = 13;
                replaceUsedCardInHand(aiHand, 13);
            }
            return;
        }

        if(enemyTowers.length>0){
            enemyTowers.sort((a,b)=>a.hp-b.hp);
            const t = enemyTowers[0];
            const ok = castSpell(t.x, t.y, 13, false);
            if(ok){
                lastAiSpawnMs = nowMs;
                lastAiUsedCardId = 13;
                replaceUsedCardInHand(aiHand, 13);
            }
            return;
        }
    }

    // obƒças dej ≈°t√≠t na nejv√≠c po≈°kozenou vƒõ≈æ (jen pokud je v ruce)
    if(aiHand.includes(7) && cards[7] && aiElixir >= cards[7].cost && Math.random() < 0.16){
        const alive = aiTowers.filter(t=>t.hp>0);
        if(alive.length>0){
            alive.sort((a,b)=> (a.hp/a.maxHp) - (b.hp/b.maxHp));
            const t = alive[0];
            const ok = castSpell(t.x, t.y, 7, false);
            if(ok){
                lastAiSpawnMs = nowMs;
                lastAiUsedCardId = 7;
                replaceUsedCardInHand(aiHand, 7);
            }
            return;
        }
    }

    // obƒças pou≈æij Skel barell na vƒõ≈æ (jen pokud je v ruce)
    if(aiHand.includes(14) && cards[14] && aiElixir >= cards[14].cost && Math.random() < 0.18){
        const enemyTowers = playerTowers.filter(t=>t.hp>0);
        if(enemyTowers.length>0){
            enemyTowers.sort((a,b)=>a.hp-b.hp);
            const t = enemyTowers[0];
            const ok = castSpell(t.x, t.y, 14, false);
            if(ok){
                lastAiSpawnMs = nowMs;
                lastAiUsedCardId = 14;
                replaceUsedCardInHand(aiHand, 14);
            }
            return;
        }
    }

    // vyber jednotku: v√°≈æenƒõ (aby AI nehr√°la po≈ô√°d luƒçi≈°tnice)
    const affordable = [1,2,3,5,8,9,10,11,12].filter(id=>aiHand.includes(id) && cards[id].cost <= aiElixir);
    const options = affordable.map(id=>{
        const c = cards[id];
        // preferuj dra≈æ≈°√≠ (kdy≈æ jsou dostupn√©), ale luƒçi≈°tnice a≈• nen√≠ default
        let w = Math.pow(c.cost, 1.35);
        if(id === 2) w *= 0.55;
        if(id === 1) w *= 1.10;
        return { id, w };
    });
    if(options.length === 0) return;

    let card = weightedPick(options);
    // avoid repeating same unit too often
    if(lastAiUnitCardId && card === lastAiUnitCardId && options.length > 1 && Math.random() < 0.75){
        const others = options.filter(o=>o.id !== lastAiUnitCardId);
        card = weightedPick(others);
    }

    // spawn v horn√≠ polovinƒõ, preferuj okolo most≈Ø (vypad√° to chyt≈ôeji)
    const biasBridge = Math.random() < 0.7;
    const x = biasBridge ? (Math.random()<0.5 ? BRIDGES_X[0] : BRIDGES_X[1]) + (Math.random()*90 - 45) : (Math.random()*ARENA_W);
    const y = 58 + Math.random()*60;
    const ok = spawnUnit(x, y, card, false);
    if(ok){
        lastAiSpawnMs = nowMs;
        lastAiUnitCardId = card;
        lastAiUsedCardId = card;
        replaceUsedCardInHand(aiHand, card);
    }
}

// elix√≠r regen (plynulej≈°√≠)
setInterval(()=>{
    if(gameOver) return;
    if(!gameStarted) return;
    elixir = Math.min(elixir + 1, 10);
    aiElixir = Math.min(aiElixir + 1, 10);
    updateHud();
}, 2500);

function gameLoop(nowMs){
    const dtMs = Math.min(40, nowMs - lastTickMs); // clamp kv≈Øli tab switch
    lastTickMs = nowMs;

    if(!gameStarted){
        requestAnimationFrame(gameLoop);
        return;
    }

    updateHudTimeAndTrophies(nowMs);

    aiThink(nowMs);
    updateTowers(nowMs);
    updateUnits(nowMs, dtMs);
    updateProjectiles(dtMs);
    removeDead();

    if(inSuddenDeath){
        applySuddenDeathDrain(dtMs / 1000);
    }

    checkGameOver(nowMs);

    requestAnimationFrame(gameLoop);
}

renderDeckPicker();
document.getElementById("deckStart").onclick = startGame;
updateHud();

requestAnimationFrame(gameLoop);
</script>

</body>
</html>
