<!DOCTYPE html>
<html lang="cs">
<head>
<meta charset="UTF-8">
<title>Mini Clash Royale s AI</title>
<style>
:root{
    --bg:#0f1115;
    --panel:#151822;
    --panel2:#10131b;
    --text:#e9eefc;
    --muted:#a8b3d6;
    --accent:#6ee7ff;

    --grass1:#2e7d32;
    --grass2:#276a2b;
    --river1:#1b66ff;
    --river2:#1bb1ff;
    --bridge1:#7a5a44;
    --bridge2:#5d4636;

    --red:#ef4444;
    --blue:#3b82f6;
}

body{
    margin:0;
    background:radial-gradient(1200px 700px at 50% -20%, #27325a 0%, var(--bg) 55%),
               radial-gradient(900px 500px at 10% 20%, rgba(110,231,255,.12) 0%, transparent 60%),
               radial-gradient(900px 500px at 90% 20%, rgba(239,68,68,.10) 0%, transparent 60%);
    color:var(--text);
    font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    text-align:center;
}

h1{ margin:18px 0 6px; letter-spacing:.2px; }
p{ color:var(--muted); margin:8px 0; }

#arena{
    width:600px;
    height:450px;
    margin:18px auto;
    position:relative;
    border-radius:18px;
    border:1px solid rgba(255,255,255,.12);
    box-shadow:0 20px 60px rgba(0,0,0,.45);
    overflow:hidden;
    background:
        radial-gradient(120px 120px at 15% 25%, rgba(255,255,255,.08) 0%, transparent 60%),
        radial-gradient(140px 140px at 85% 70%, rgba(255,255,255,.06) 0%, transparent 60%),
        repeating-linear-gradient(45deg, rgba(255,255,255,.06) 0 8px, rgba(255,255,255,.02) 8px 16px),
        linear-gradient(180deg, var(--grass1), var(--grass2));
}

.arena-vignette{
    position:absolute;
    inset:-40px;
    pointer-events:none;
    background:radial-gradient(closest-side, transparent 55%, rgba(0,0,0,.35) 100%);
}

.river{
    position:absolute;
    top:200px;
    width:100%;
    height:50px;
    background:
        linear-gradient(90deg, rgba(255,255,255,.12), rgba(255,255,255,0) 30%, rgba(255,255,255,.10) 60%, rgba(255,255,255,0)),
        repeating-linear-gradient(135deg, rgba(255,255,255,.10) 0 10px, rgba(255,255,255,.04) 10px 20px),
        linear-gradient(180deg, var(--river1), var(--river2));
    background-size:140px 50px, 120px 50px, auto;
    animation:water 3.2s linear infinite;
    box-shadow:inset 0 0 0 1px rgba(255,255,255,.14);
}

@keyframes water{
    from{ background-position:0 0, 0 0, 0 0; }
    to{ background-position:140px 0, -120px 0, 0 0; }
}

.bridge{
    position:absolute;
    top:200px;
    width:88px;
    height:50px;
    border-radius:10px;
    background:
        repeating-linear-gradient(90deg, rgba(255,255,255,.10) 0 8px, rgba(0,0,0,.10) 8px 16px),
        linear-gradient(180deg, var(--bridge1), var(--bridge2));
    box-shadow:0 10px 18px rgba(0,0,0,.35), inset 0 0 0 1px rgba(255,255,255,.10);
}
.bridge.left{ left:106px; }
.bridge.right{ right:106px; }

.tower{
    width:86px;
    height:86px;
    position:absolute;
    border-radius:16px;
    display:flex;
    flex-direction:column;
    align-items:center;
    justify-content:center;
    gap:6px;
    font-weight:800;
    user-select:none;
    box-shadow:0 18px 30px rgba(0,0,0,.35);
    border:1px solid rgba(255,255,255,.16);
}

.tower::before{
    content:"";
    position:absolute;
    top:-10px;
    left:10px;
    right:10px;
    height:16px;
    border-radius:12px;
    background:linear-gradient(180deg, rgba(255,255,255,.24), rgba(255,255,255,.06));
    box-shadow:0 8px 18px rgba(0,0,0,.25);
}

.tower.red{ background:linear-gradient(180deg, rgba(239,68,68,.95), rgba(127,29,29,.92)); bottom:10px; }
.tower.blue{ background:linear-gradient(180deg, rgba(59,130,246,.95), rgba(30,58,138,.92)); top:10px; }

.tower-value{ font-size:20px; line-height:1; color:rgba(255,255,255,.95); }
.tower-hpbar{
    width:72px;
    height:8px;
    border-radius:999px;
    background:rgba(0,0,0,.35);
    overflow:hidden;
    box-shadow:inset 0 0 0 1px rgba(255,255,255,.12);
}
.tower-hpfill{
    height:100%;
    width:100%;
    background:linear-gradient(90deg, #34d399, #22c55e);
}

.unit{
    position:absolute;
    width:44px;
    height:44px;
    transform:translate(-50%, -50%);
    border-radius:999px;
    display:flex;
    align-items:center;
    justify-content:center;
    font-size:26px;
    box-shadow:0 10px 16px rgba(0,0,0,.35);
    border:1px solid rgba(255,255,255,.18);
    background:radial-gradient(circle at 30% 25%, rgba(255,255,255,.20), rgba(255,255,255,.04) 55%, rgba(0,0,0,.15));
    user-select:none;
}

/* Make teams very easy to recognize */
.unit.player{
    outline:none;
    border-color:rgba(239,68,68,.55);
    background:
        radial-gradient(circle at 30% 25%, rgba(255,255,255,.22), rgba(255,255,255,.06) 55%, rgba(0,0,0,.18)),
        radial-gradient(circle at 50% 50%, rgba(239,68,68,.22), rgba(239,68,68,0) 70%);
    box-shadow:
        0 10px 16px rgba(0,0,0,.35),
        0 0 0 3px rgba(239,68,68,.22),
        0 0 22px rgba(239,68,68,.18);
}

.unit.ai{
    outline:none;
    border-color:rgba(59,130,246,.55);
    background:
        radial-gradient(circle at 30% 25%, rgba(255,255,255,.22), rgba(255,255,255,.06) 55%, rgba(0,0,0,.18)),
        radial-gradient(circle at 50% 50%, rgba(59,130,246,.22), rgba(59,130,246,0) 70%);
    box-shadow:
        0 10px 16px rgba(0,0,0,.35),
        0 0 0 3px rgba(59,130,246,.22),
        0 0 22px rgba(59,130,246,.18);
}


.unit-face{ line-height:1; transform-origin:50% 50%; }

.unit-value{
    position:absolute;
    top:6px;
    left:50%;
    transform:translateX(-50%);
    font-weight:900;
    font-size:14px;
    color:rgba(255,255,255,.95);
    text-shadow:0 2px 10px rgba(0,0,0,.55);
    pointer-events:none;

.unit.frozen{
    filter:saturate(.75) brightness(1.05);
    box-shadow:
        0 10px 16px rgba(0,0,0,.35),
        0 0 0 3px rgba(147,197,253,.18),
        0 0 20px rgba(59,130,246,.14);
}
}

/* Wall (Zeƒè): wide like bridge, thin like fish */
.unit.wall{
    width:88px;
    height:12px;
    border-radius:10px;
    font-size:0;
    background:linear-gradient(180deg, rgba(203,213,225,.92), rgba(100,116,139,.90));
    border-color:rgba(255,255,255,.14);
    box-shadow:0 10px 16px rgba(0,0,0,.30), inset 0 0 0 1px rgba(255,255,255,.10);
}
.unit.wall.player,
.unit.wall.ai{
    background:linear-gradient(180deg, rgba(203,213,225,.92), rgba(100,116,139,.90));
    border-color:rgba(255,255,255,.14);
    box-shadow:0 10px 16px rgba(0,0,0,.30), inset 0 0 0 1px rgba(255,255,255,.10);
}
.unit.wall .unit-face{ display:none; }

/* X-bow: add a tiny tip marker to guarantee direction */
.unit.xbow-emoji .unit-face{
    position:relative;
    display:block;
}
.unit.xbow-emoji .unit-face::after{
    content:"";
    position:absolute;
    left:50%;
    top:50%;
    width:0;
    height:0;
    transform:translate(16px, -50%);
    border-left:7px solid rgba(255,255,255,.85);
    border-top:4px solid transparent;
    border-bottom:4px solid transparent;
    filter:drop-shadow(0 6px 8px rgba(0,0,0,.22));
    opacity:.85;
}

.unit-hp{
    position:absolute;
    bottom:-10px;
    left:50%;
    width:46px;
    height:7px;
    transform:translateX(-50%);
    border-radius:999px;
    background:rgba(0,0,0,.40);
    overflow:hidden;
    box-shadow:inset 0 0 0 1px rgba(255,255,255,.12);
}
.unit-hpfill{ height:100%; width:100%; background:linear-gradient(90deg, #f59e0b, #ef4444); }

.projectile{
    position:absolute;
    width:8px;
    height:8px;
    border-radius:999px;
    background:radial-gradient(circle, rgba(255,255,255,.9), rgba(255,255,255,.15) 60%, rgba(0,0,0,0));
    box-shadow:0 0 14px rgba(110,231,255,.45);
    transform:translate(-50%, -50%);
    pointer-events:none;
}

.projectile.arrow{
    width:16px;
    height:4px;
    border-radius:999px;
    background:linear-gradient(90deg, rgba(255,255,255,.95), rgba(110,231,255,.65));
    box-shadow:0 0 14px rgba(110,231,255,.35);
}

.projectile.stone{
    width:10px;
    height:10px;
    background:radial-gradient(circle at 30% 30%, rgba(255,255,255,.55), rgba(0,0,0,.10) 40%, rgba(0,0,0,.0) 70%),
               radial-gradient(circle at 55% 55%, rgba(148,163,184,.95), rgba(71,85,105,.65) 60%, rgba(15,23,42,.0) 72%);
    box-shadow:0 0 12px rgba(148,163,184,.25);
}

.explosion{
    position:absolute;
    width:12px;
    height:12px;
    border-radius:999px;
    transform:translate(-50%, -50%);
    pointer-events:none;
    background:radial-gradient(circle, rgba(255,255,255,.95) 0%, rgba(255,255,255,.35) 25%, rgba(255,255,255,0) 70%);
    box-shadow:0 0 28px rgba(255,255,255,.18);
    animation:boom .55s ease-out forwards;
}

.explosion.rocket{
    box-shadow:0 0 34px rgba(110,231,255,.25);
    background:radial-gradient(circle, rgba(110,231,255,.95) 0%, rgba(110,231,255,.28) 28%, rgba(110,231,255,0) 72%);
}

.explosion.slam{
    box-shadow:0 0 34px rgba(239,68,68,.22);
    background:radial-gradient(circle, rgba(239,68,68,.92) 0%, rgba(239,68,68,.22) 30%, rgba(239,68,68,0) 74%);
}

.spell-radius{
    position:absolute;
    left:-9999px;
    top:-9999px;
    width:10px;
    height:10px;
    border-radius:9999px;
    border:2px solid rgba(110,231,255,.55);
    background:radial-gradient(circle, rgba(110,231,255,.10), rgba(110,231,255,0) 70%);
    transform:translate(-50%, -50%);
    pointer-events:none;
    box-shadow:0 0 24px rgba(110,231,255,.12);
    z-index:5;
}

@keyframes boom{
    0%{ opacity:.95; width:14px; height:14px; filter:blur(0px); }
    100%{ opacity:0; width:180px; height:180px; filter:blur(.5px); }
}

#hud{
    width:600px;
    margin:0 auto;
    display:flex;
    align-items:center;
    justify-content:space-between;
    gap:12px;
}

.pill{
    flex:1;
    background:linear-gradient(180deg, rgba(255,255,255,.07), rgba(255,255,255,.03));
    border:1px solid rgba(255,255,255,.10);
    border-radius:14px;
    padding:10px 12px;
    text-align:left;
}

.elixir-row{ display:flex; align-items:center; justify-content:space-between; gap:10px; }
.elixir-bar{ flex:1; height:10px; background:rgba(0,0,0,.35); border-radius:999px; overflow:hidden; box-shadow:inset 0 0 0 1px rgba(255,255,255,.10); }
.elixir-fill{ height:100%; width:50%; background:linear-gradient(90deg, #a855f7, #22d3ee); }

#ui{
    width:600px;
    margin:10px auto 16px;
    display:flex;
    justify-content:center;
    gap:10px;
    flex-wrap:wrap;
}

.river-fish{
    position:absolute;
    left:40px;
    top:232px;
    transform:translate(-50%, -50%);
    font-size:22px;
    opacity:.9;
    pointer-events:none;
    filter:drop-shadow(0 10px 12px rgba(0,0,0,.35));
    animation:swim 14s linear infinite;
}

@keyframes swim{
    0%{ left:-30px; transform:translate(-50%, -50%) scaleX(1); }
    48%{ left:630px; transform:translate(-50%, -50%) scaleX(1); }
    50%{ left:630px; transform:translate(-50%, -50%) scaleX(-1); }
    98%{ left:-30px; transform:translate(-50%, -50%) scaleX(-1); }
    100%{ left:-30px; transform:translate(-50%, -50%) scaleX(1); }
}

#ui button{
    background:linear-gradient(180deg, rgba(255,255,255,.09), rgba(255,255,255,.02));
    color:var(--text);
    border:1px solid rgba(255,255,255,.12);
    border-radius:14px;
    padding:10px 12px;
    font-size:14px;
    cursor:pointer;
    min-width:140px;
    position:relative;
}

#ui button:hover{ border-color:rgba(110,231,255,.35); }
#ui button.selected{ border-color:rgba(110,231,255,.65); box-shadow:0 0 0 3px rgba(110,231,255,.10); }
#ui button:disabled{ opacity:.45; cursor:not-allowed; }

#log{ width:600px; margin:0 auto 18px; min-height:22px; color:rgba(255,255,255,.85); }

.ability-btn{
    position:absolute;
    right:12px;
    bottom:12px;
    z-index:25;
    background:linear-gradient(180deg, rgba(255,255,255,.09), rgba(255,255,255,.02));
    color:var(--text);
    border:1px solid rgba(255,255,255,.12);
    border-radius:14px;
    padding:10px 12px;
    font-size:14px;
    font-weight:900;
    cursor:pointer;
    min-width:140px;
}
.ability-btn:hover{ border-color:rgba(110,231,255,.35); }
.ability-btn:disabled{ opacity:.45; cursor:not-allowed; }

.end-overlay{
    position:absolute;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    background:rgba(0,0,0,.35);
    backdrop-filter: blur(2px);
    z-index:20;
}

.end-overlay.hidden{ display:none; }

.end-card{
    min-width:260px;
    padding:16px 18px;
    border-radius:16px;
    border:1px solid rgba(255,255,255,.16);
    background:linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
    box-shadow:0 18px 50px rgba(0,0,0,.45);
    font-weight:900;
    font-size:22px;
    color:rgba(255,255,255,.95);
    position:relative;
}

.end-topbar{
    position:absolute;
    top:10px;
    left:10px;
    right:10px;
    display:flex;
    justify-content:space-between;
    gap:10px;
}
.end-topbar button{
    background:linear-gradient(180deg, rgba(255,255,255,.09), rgba(255,255,255,.02));
    color:var(--text);
    border:1px solid rgba(255,255,255,.12);
    border-radius:12px;
    padding:8px 10px;
    font-size:12px;
    font-weight:900;
    cursor:pointer;
}
.end-topbar button:hover{ border-color:rgba(110,231,255,.35); }

.end-panel{
    margin-top:10px;
    padding:10px 12px;
    border-radius:14px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(0,0,0,.18);
    font-size:13px;
    font-weight:700;
    color:rgba(255,255,255,.92);
    text-align:left;
    max-height:200px;
    overflow:auto;
}
.end-panel.hidden{ display:none; }

.end-title{ margin-bottom:12px; }
.end-actions{
    display:flex;
    gap:10px;
    justify-content:space-between;
}
.end-actions button{
    flex:1;
    background:linear-gradient(180deg, rgba(255,255,255,.09), rgba(255,255,255,.02));
    color:var(--text);
    border:1px solid rgba(255,255,255,.12);
    border-radius:14px;
    padding:10px 12px;
    font-size:14px;
    font-weight:800;
    cursor:pointer;
}
.end-actions button:hover{ border-color:rgba(110,231,255,.35); }

.deck-overlay{
    position:absolute;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    background:rgba(0,0,0,.45);
    backdrop-filter: blur(2px);
    z-index:30;
}
.deck-overlay.hidden{ display:none; }
.gift-modal{
    position:fixed;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    background:rgba(0,0,0,.60);
    backdrop-filter: blur(3px);
    z-index:50;
}
.gift-modal.hidden{ display:none; }
.gift-card{
    width:min(400px, calc(100% - 24px));
    padding:20px;
    border-radius:16px;
    border:2px solid rgba(255,215,0,.30);
    background:linear-gradient(180deg, rgba(255,215,0,.08), rgba(255,215,0,.02));
    text-align:center;
    box-shadow:0 0 40px rgba(255,215,0,.15);
}

.spin-modal{
    position:fixed;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    background:rgba(0,0,0,.60);
    backdrop-filter: blur(3px);
    z-index:50;
}
.spin-modal.hidden{ display:none; }
.spin-card{
    width:min(400px, calc(100% - 24px));
    padding:24px;
    border-radius:16px;
    border:2px solid rgba(255,165,0,.30);
    background:linear-gradient(180deg, rgba(255,165,0,.08), rgba(255,165,0,.02));
    text-align:center;
    box-shadow:0 0 40px rgba(255,165,0,.15);
}

.lobby-overlay{
    position:fixed;
    inset:0;
    display:flex;
    align-items:center;
    justify-content:center;
    background:linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
    z-index:40;
}
.lobby-overlay.hidden{ display:none; }
.lobby-card{
    width:min(500px, calc(100% - 24px));
    padding:32px;
    border-radius:16px;
    border:2px solid rgba(255,215,0,.20);
    background:rgba(0,0,0,.40);
    text-align:center;
    box-shadow:0 0 60px rgba(255,215,0,.10);
}

.deck-card{
    width:min(560px, calc(100% - 24px));
    padding:14px 14px 12px;
    border-radius:16px;
    border:1px solid rgba(255,255,255,.16);
    background:linear-gradient(180deg, rgba(255,255,255,.10), rgba(255,255,255,.04));
    box-shadow:0 18px 50px rgba(0,0,0,.45);
}
.deck-title{ font-weight:900; font-size:18px; margin-bottom:8px; }
.deck-sub{ opacity:.85; margin-bottom:10px; font-size:13px; }
.deck-grid{ display:flex; flex-wrap:wrap; gap:10px; justify-content:center; }
.deck-grid button{ min-width:172px; }
.deck-grid button.picked{ border-color:rgba(110,231,255,.65); box-shadow:0 0 0 3px rgba(110,231,255,.10); }
.deck-actions{ display:flex; justify-content:space-between; align-items:center; margin-top:10px; gap:10px; }
.deck-actions .hint{ opacity:.85; font-size:13px; }
.deck-actions .start{ min-width:180px; }
</style>
</head>
<body>

<h1>Mini Clash Royale üè∞</h1>
<p>Klikni na svoji polovinu pro vykl√°d√°n√≠ jednotky (spodn√≠ ƒç√°st ar√©ny).</p>

<div id="arena">
    <div class="river"></div>

    <div class="river-fish" aria-hidden="true">üêü</div>
    <div class="bridge left"></div>
    <div class="bridge right"></div>
    <div class="arena-vignette"></div>

    <!-- MODR√â Vƒö≈ΩE -->
    <div class="tower blue" style="left:60px" id="ai0"></div>
    <div class="tower blue" style="left:260px" id="ai1"></div>
    <div class="tower blue" style="left:460px" id="ai2"></div>

    <!-- ƒåERVEN√â Vƒö≈ΩE -->
    <div class="tower red" style="left:60px" id="pl0"></div>
    <div class="tower red" style="left:260px" id="pl1"></div>
    <div class="tower red" style="left:460px" id="pl2"></div>

    <div id="endOverlay" class="end-overlay hidden" aria-live="polite">
        <div class="end-card">
            <div class="end-topbar">
                <button id="endTrophyRoad">üèÜ Trophy road</button>
                <button id="endLeaderboard">üìã Leaderboard</button>
            </div>
            <div class="end-title" id="endText"></div>
            <div id="endPanel" class="end-panel hidden"></div>
            <div class="end-actions">
                <button id="endSame">Hr√°t se stejn√Ωma kartama</button>
                <button id="endNew">Hr√°t s jin√Ωma kartama</button>
            </div>
            <div class="end-actions" style="margin-top:10px;">
                <button id="endRandom">Hra s random kartama</button>
                <button id="endGift">üéÅ Vyzvedni si d√°rek</button>
            </div>
            <div class="end-actions" style="margin-top:10px;">
                <button id="endSpin">üé° Koleƒçko ≈†tƒõst√≠</button>
            </div>
        </div>
    </div>

    <div id="giftModal" class="gift-modal hidden" aria-live="polite">
        <div class="gift-card">
            <div style="font-size:80px; margin-bottom:16px;">üéÅ</div>
            <div style="font-size:18px; font-weight:bold; margin-bottom:12px;">Vyzvedni si v√°noƒçn√≠ d√°rek!</div>
            <div style="opacity:.85; margin-bottom:16px;">Napi≈° tajn√© heslo:</div>
            <input type="text" id="giftInput" placeholder="Heslo..." style="width:100%; padding:8px 12px; border:1px solid rgba(255,255,255,.12); border-radius:8px; background:rgba(255,255,255,.08); color:var(--text); font-size:14px; text-align:center;" />
            <div id="giftMessage" style="margin-top:12px; font-size:14px; opacity:.85;"></div>
            <div style="margin-top:16px; display:flex; gap:10px;">
                <button onclick="checkGift()" style="flex:1;">Zkontrolovat</button>
                <button onclick="closeGift()" style="flex:1;">Zav≈ô√≠t</button>
            </div>
        </div>
    </div>

    <div id="lobbyOverlay" class="lobby-overlay hidden" aria-live="polite">
        <div class="lobby-card">
            <div style="font-size:48px; margin-bottom:20px;">‚öîÔ∏è Clash Royale</div>
            <div style="font-size:24px; margin-bottom:30px;">üèÜ Trofeje: <strong id="lobbyTrophies">0</strong></div>
            
            <!-- Mini Arena with characters -->
            <div style="width:300px; height:200px; margin:0 auto 30px; border-radius:12px; background:linear-gradient(180deg,var(--grass1),var(--grass2)); border:2px solid rgba(255,215,0,.5); position:relative; overflow:hidden;">
                <div style="position:absolute; left:30px; top:50%; transform:translateY(-50%); font-size:60px;">üó°Ô∏è</div>
                <div style="position:absolute; left:130px; top:50%; transform:translateY(-50%); font-size:60px;">‚öîÔ∏è</div>
                <div style="position:absolute; right:30px; top:50%; transform:translateY(-50%); font-size:60px;">üõ°Ô∏è</div>
            </div>
            
            <div style="display:flex; gap:10px; margin-bottom:20px;">
                <button id="lobbyTrophyRoad" style="flex:1; padding:12px; background:linear-gradient(135deg,#ffd700,#ffed4e); border:none; border-radius:8px; font-weight:bold; cursor:pointer;">üèÜ Trophy Road</button>
                <button id="lobbyLeaderboard" style="flex:1; padding:12px; background:linear-gradient(135deg,#87ceeb,#b0e0e6); border:none; border-radius:8px; font-weight:bold; cursor:pointer;">üìã Leaderboard</button>
            </div>
            
            <div id="lobbyContent" style="min-height:200px; margin-bottom:20px; padding:15px; border-radius:8px; background:rgba(255,255,255,.05); font-size:14px; max-height:300px; overflow-y:auto;"></div>
            
            <button id="lobbyPlay" style="width:100%; padding:16px; font-size:18px; font-weight:bold; background:linear-gradient(135deg,#4CAF50,#45a049); border:none; border-radius:8px; color:white; cursor:pointer; margin-bottom:10px;">‚ñ∂Ô∏è Hr√°t</button>
            <button id="lobbySpin" style="width:100%; padding:12px; background:linear-gradient(135deg,#ff6b6b,#ee5a6f); border:none; border-radius:8px; color:white; cursor:pointer;">üé° Koleƒçko ≈†tƒõst√≠</button>
        </div>
    </div>

    <div id="spinModal" class="spin-modal hidden" aria-live="polite">
        <div class="spin-card">
            <div style="font-size:24px; font-weight:bold; margin-bottom:20px;">üé° Koleƒçko ≈†tƒõst√≠</div>
            <canvas id="spinCanvas" width="300" height="300" style="display:block; margin:0 auto 20px; background:rgba(0,0,0,.3); border-radius:12px;"></canvas>
            <div id="spinInfo" style="text-align:center; margin-bottom:20px; font-size:14px; opacity:.85;"></div>
            <button id="spinButton" onclick="spinWheel()" style="width:100%; padding:12px; font-size:16px; font-weight:bold; background:linear-gradient(135deg,#ff6b6b,#ee5a6f); border:none; border-radius:8px; color:white; cursor:pointer;">Toƒçit (0/10)</button>
            <button onclick="closeSpin()" style="width:100%; padding:10px; margin-top:10px; background:rgba(255,255,255,.1); border:none; border-radius:8px; color:var(--text); cursor:pointer;">Zav≈ô√≠t</button>
        </div>
    </div>

    <div id="deckOverlay" class="deck-overlay" aria-live="polite">
        <div class="deck-card">
            <div class="deck-title">Vyber 4 karty</div>
            <div class="deck-sub">Klikni na karty (mus√≠ b√Ωt p≈ôesnƒõ 4), pak stiskni Start.</div>
            <div class="deck-grid" id="deckGrid"></div>
            <div class="deck-actions">
                <div class="hint" id="deckHint">Vybr√°no: 0 / 4</div>
                <button class="start" id="deckStart" disabled>Start</button>
            </div>
        </div>
    </div>

    <button id="moleAbility" class="ability-btn" disabled>ü™è Krtek (1‚ö°)</button>
</div>

<div id="hud">
    <div class="pill">
        <div class="elixir-row">
            <div>‚ö° Elix√≠r: <strong><span id="elixir">5</span></strong> / 10</div>
            <div style="opacity:.85">AI: <strong><span id="aiElixir">5</span></strong></div>
        </div>
        <div class="elixir-row" style="margin-top:6px; font-size:13px; opacity:.95;">
            <div>‚è±Ô∏è ƒåas: <strong><span id="timeLeft">1:00</span></strong></div>
            <div>üèÜ Trophy: <strong><span id="trophies">0</span></strong></div>
        </div>
        <div class="elixir-row" style="margin-top:6px; font-size:12px; opacity:.85;">
            <div id="stats">üìä W: 0 L: 0</div>
        </div>
        <div class="elixir-bar" aria-hidden="true"><div class="elixir-fill" id="elixirFill"></div></div>
    </div>
</div>

<div id="ui">
    <!-- Hand is rendered by JS (4 cards) -->
</div>

<p id="log"></p>

<script>
const arena = document.getElementById("arena");
const ARENA_W = 600;
const ARENA_H = 450;
const RIVER_Y = 200;
const RIVER_H = 50;
const BRIDGES_X = [150, 450];
const BRIDGE_Y = RIVER_Y + RIVER_H / 2;

let elixir = 5;
let aiElixir = 5;
let selectedCard = null;
let lastAiSpawnMs = 0;
let lastTickMs = performance.now();
let gameOver = false;
let lastAiUnitCardId = null;
let gameStarted = false;
let playerRotWall = null;
let playerMole = null;
let moleCooldownUntilMs = 0;
let matchStartMs = 0;
const MOLE_TUNNEL_COST = 1;
const ALL_CARDS = [1,2,3,5,6,7,8,9,10,11,12,13,14,15,25,26,27];
const HAND_SIZE = 4;
let playerHand = [];
let aiHand = [];
let lastPlayerUsedCardId = null;
let lastAiUsedCardId = null;

// Match rules
const MATCH_MS = 180_000;
const SUDDEN_DEATH_TOWER_DRAIN_PER_SEC = 10;
const SUDDEN_DEATH_ELIXIR_MULTIPLIER = 2;
let inSuddenDeath = false;

let playerDeck = [];
let selectedDeck = new Set();

let lastAiStartHandKey = null;

// Sniper targeting
arena.addEventListener("click", (e)=>{
    const clickedEl = e.target;
    const unitEl = clickedEl.closest(".unit");
    if(!unitEl) return;
    
    // Find which unit was clicked
    const targetId = unitEl.dataset.unitId;
    if(!targetId) return;
    
    // Find which sniper the player is currently targeting with
    const activeSnipers = playerUnits.filter(u => u.cardId === 25 && !u.sniperTarget);
    if(activeSnipers.length === 0) return;
    
    const sniper = activeSnipers[0];
    const targetUnit = aiUnits.find(u => u.id === targetId && u.hp > 0);
    if(!targetUnit) return;
    
    sniper.sniperTarget = targetUnit;
    updateHud();
});

function handKey(hand){
    return [...hand].slice().sort((a,b)=>a-b).join(",");
}

function pickAiStartHandDifferent(){
    // Try a few times to avoid the same 4 cards as last round
    const pool = getUnlockedPool();
    // AI cannot use Mega Mini P.E.K.K.A (card 27)
    const aiPool = pool.filter(id => id !== 27);
    let candidate = shuffle([...aiPool]).slice(0, HAND_SIZE);
    if(!lastAiStartHandKey){
        lastAiStartHandKey = handKey(candidate);
        return candidate;
    }
    for(let i=0;i<12;i++){
        const key = handKey(candidate);
        if(key !== lastAiStartHandKey){
            lastAiStartHandKey = key;
            return candidate;
        }
        candidate = shuffle([...aiPool]).slice(0, HAND_SIZE);
    }
    // Fallback: accept (extremely unlikely unless pool is tiny)
    lastAiStartHandKey = handKey(candidate);
    return candidate;
}

const logEl = document.getElementById("log");
const elixirEl = document.getElementById("elixir");
const aiElixirEl = document.getElementById("aiElixir");
const elixirFillEl = document.getElementById("elixirFill");
const timeLeftEl = document.getElementById("timeLeft");
const trophiesEl = document.getElementById("trophies");
const statsEl = document.getElementById("stats");
const endOverlayEl = document.getElementById("endOverlay");
const endTextEl = document.getElementById("endText");
const endPanelEl = document.getElementById("endPanel");
const endSameBtn = document.getElementById("endSame");
const endNewBtn = document.getElementById("endNew");
const endRandomBtn = document.getElementById("endRandom");
const endTrophyRoadBtn = document.getElementById("endTrophyRoad");
const endLeaderboardBtn = document.getElementById("endLeaderboard");
const moleAbilityBtn = document.getElementById("moleAbility");

const TROPHIES_KEY = "mini_cr_trophies_v1";
const LEADERBOARD_KEY = "mini_cr_leaderboard_v1";
const STATS_KEY = "mini_cr_stats_v1";
const UPGRADE_KEY = "mini_cr_upgrade_v1";
let trophies = Number(localStorage.getItem(TROPHIES_KEY) || 0) || 0;

function loadStats(){
    try{
        const raw = localStorage.getItem(STATS_KEY);
        const obj = raw ? JSON.parse(raw) : {};
        return {
            wins: obj.wins || 0,
            losses: obj.losses || 0,
            winStreak: obj.winStreak || 0,
            gamesSinceLastSpin: obj.gamesSinceLastSpin || 0,
            spinCount: obj.spinCount || 0
        };
    }catch(e){
        return { wins: 0, losses: 0, winStreak: 0, gamesSinceLastSpin: 0, spinCount: 0 };
    }
}

let stats = loadStats();

function saveStats(){
    try{ localStorage.setItem(STATS_KEY, JSON.stringify(stats)); }catch(e){}
}

function saveTrophies(){
    trophies = Math.max(0, Math.floor(trophies));
    localStorage.setItem(TROPHIES_KEY, String(trophies));
}

function loadLeaderboard(){
    try{
        const raw = localStorage.getItem(LEADERBOARD_KEY);
        const arr = raw ? JSON.parse(raw) : [];
        return Array.isArray(arr) ? arr : [];
    }catch(e){
        return [];
    }
}

function saveLeaderboard(list){
    try{ localStorage.setItem(LEADERBOARD_KEY, JSON.stringify(list)); }catch(e){}
}

function pushLeaderboardEntry(){
    const list = loadLeaderboard();
    const matchDurationMs = matchStartMs ? (performance.now() - matchStartMs) : MATCH_MS;
    list.push({ trophies, matchTimeMs: matchDurationMs, at: new Date().toISOString() });
    list.sort((a,b)=> (b.trophies||0) - (a.trophies||0));
    saveLeaderboard(list.slice(0, 25));
}

function trophyDelta(playerWon, playerAliveTowers){
    const n = Math.max(0, Math.min(3, playerAliveTowers));
    const base = (n === 3 ? 30 : (n === 2 ? 20 : 10));
    return playerWon ? base : -base;
}

function getUnlockedPool(){
    // Base unlocked at start
    const pool = new Set([3,2,13,1]);
    if(trophies >= 100){
        [9,6,8,7].forEach(id=>pool.add(id));
    }
    if(trophies >= 250){
        [12,14,11].forEach(id=>pool.add(id));
    }
    if(trophies >= 500){
        [5,10,25].forEach(id=>pool.add(id));
    }
    if(trophies >= 750){
        [15,26].forEach(id=>pool.add(id));
    }
    if(trophies >= 10000){
        pool.add(27);
    }
    // Add upgrade if available
    const upgrade = localStorage.getItem(UPGRADE_KEY);
    if(upgrade === "20" || upgrade === "21"){
        pool.add(Number(upgrade));
    }
    return [...pool].filter(id=>ALL_CARDS.includes(id) || id === 20 || id === 21 || id === 25 || id === 26 || id === 27);
}

function trophyRoadHtml(){
    const line = (need, ids)=>{
        const unlocked = trophies >= need;
        const items = ids.map(id=>{
            const c = cards[id];
            return c ? `${c.emoji} ${c.name}` : `#${id}`;
        }).join(" ¬∑ ");
        return `${unlocked ? "‚úÖ" : "üîí"} ${need}üèÜ: ${items}`;
    };
    const base = [3,2,13,1].map(id=>{ const c = cards[id]; return c ? `${c.emoji} ${c.name}` : `#${id}`; }).join(" ¬∑ ");
    return [
        `Tvoje trophy: <strong>${trophies}</strong>`,
        `‚úÖ 0üèÜ: ${base}`,
        line(100,[9,6,8,7]),
        line(250,[12,14,11]),
        line(500,[5,10,25]),
        line(750,[15,26]),
        line(10000,[27])
    ].join("<br>");
}

function leaderboardHtml(){
    const list = loadLeaderboard().slice().sort((a,b)=> (a.matchTimeMs||Infinity) - (b.matchTimeMs||Infinity)).slice(0, 10);
    if(list.length === 0) return "Zat√≠m pr√°zdn√©.";
    return list.map((e,i)=>{
        const when = (e.at ? e.at.slice(0,10) : "");
        const secs = Math.round((e.matchTimeMs||0) / 1000);
        const mins = Math.floor(secs / 60);
        const sec = secs % 60;
        const timeStr = `${mins}:${String(sec).padStart(2, '0')}`;
        return `${i+1}. ${timeStr} (${e.trophies}üèÜ) <span style="opacity:.75">${when}</span>`;
    }).join("<br>");
}

function toggleEndPanel(mode){
    if(!endPanelEl) return;
    if(endPanelEl.dataset.mode === mode && !endPanelEl.classList.contains("hidden")){
        endPanelEl.classList.add("hidden");
        endPanelEl.dataset.mode = "";
        endPanelEl.innerHTML = "";
        return;
    }
    endPanelEl.classList.remove("hidden");
    endPanelEl.dataset.mode = mode;
    endPanelEl.innerHTML = (mode === "road") ? trophyRoadHtml() : leaderboardHtml();
}

if(endTrophyRoadBtn) endTrophyRoadBtn.onclick = ()=>toggleEndPanel("road");
if(endLeaderboardBtn) endLeaderboardBtn.onclick = ()=>toggleEndPanel("lb");

function updateMoleAbilityUi(nowMs = performance.now()){
    if(!moleAbilityBtn) return;
    const haveMole = !!(playerMole && playerMole.hp > 0);
    const cdLeft = Math.max(0, moleCooldownUntilMs - nowMs);
    const ready = haveMole && cdLeft <= 0 && !gameOver && gameStarted;
    const canPay = elixir >= MOLE_TUNNEL_COST;
    moleAbilityBtn.disabled = !(ready && canPay);
    if(!gameStarted){
        moleAbilityBtn.innerText = `ü™è Krtek (${MOLE_TUNNEL_COST}‚ö°)`;
        return;
    }
    if(!haveMole){
        moleAbilityBtn.innerText = `ü™è Krtek (${MOLE_TUNNEL_COST}‚ö°)`;
        return;
    }
    if(cdLeft > 0){
        moleAbilityBtn.innerText = `ü™è Krtek (${Math.ceil(cdLeft/1000)}s)`;
        return;
    }
    moleAbilityBtn.innerText = `ü™è Krtek (${MOLE_TUNNEL_COST}‚ö°)`;
}

if(moleAbilityBtn){
    moleAbilityBtn.addEventListener("click", ()=>{
        const nowMs = performance.now();
        if(gameOver || !gameStarted) return;
        if(!playerMole || playerMole.hp <= 0){
            setLog("Nem√°≈° ≈æ√°dn√©ho krtka.");
            updateMoleAbilityUi(nowMs);
            return;
        }
        if(nowMs < moleCooldownUntilMs){
            setLog("ü™è Schopnost je na cooldownu.");
            updateMoleAbilityUi(nowMs);
            return;
        }
        if(elixir < MOLE_TUNNEL_COST){
            setLog("Nem√°≈° dost elix√≠ru.");
            updateMoleAbilityUi(nowMs);
            return;
        }

        elixir -= MOLE_TUNNEL_COST;
        moleCooldownUntilMs = nowMs + 10000;

        spawnExplosion(playerMole.x, playerMole.y, "rocket");
        playerMole.x = clamp(ARENA_W - playerMole.x, 18, ARENA_W-18);
        playerMole.hp = playerMole.maxHp;
        spawnExplosion(playerMole.x, playerMole.y, "rocket");
        renderUnit(playerMole);
        setLog("ü™è Krtek se zakopal a vyhrabal na druh√© stranƒõ!");
        updateHud();
    });
}

const spellPreviewEl = document.createElement("div");
spellPreviewEl.className = "spell-radius";
arena.appendChild(spellPreviewEl);

function hideSpellPreview(){
    spellPreviewEl.style.left = "-9999px";
    spellPreviewEl.style.top = "-9999px";
}

function tryReflectSpellByShield(tower){
    if(!tower || tower.hp <= 0) return null;
    if(!tower.isTower) return null;
    if(!tower.shieldCharges || tower.shieldCharges <= 0) return null;

    tower.shieldCharges -= 1;
    renderTower(tower);
    spawnExplosion(tower.x, tower.y, "rocket");

    const enemyTowers = tower.team === "player" ? aiTowers : playerTowers;
    const alive = enemyTowers.filter(t=>t.hp>0);
    if(alive.length === 0) return null;
    return alive[Math.floor(Math.random()*alive.length)];
}

function updateSpellPreview(x, y){
    if(!selectedCard || !gameStarted || gameOver){
        hideSpellPreview();
        return;
    }
    const card = cards[selectedCard];
    if(!card || card.type !== "spell"){
        hideSpellPreview();
        return;
    }

    // Only show AoE preview for Rocket/Zap/Skel barell
    const radius = (card.rocket && card.rocket.radius) || (card.zap && card.zap.radius) || (card.barrel && card.barrel.radius);
    if(!radius){
        hideSpellPreview();
        return;
    }

    const tx = clamp(x, 20, ARENA_W-20);
    const ty = clamp(y, 20, ARENA_H-20);
    spellPreviewEl.style.width = (radius*2) + "px";
    spellPreviewEl.style.height = (radius*2) + "px";
    spellPreviewEl.style.left = tx + "px";
    spellPreviewEl.style.top = ty + "px";
}

let playerTowers = [
    {hp:200, maxHp:200, x:60+43, y:ARENA_H-10-43, element: document.getElementById("pl0"), isTower:true, team:"player", lastShotMs:0, shieldCharges:0},
    {hp:500, maxHp:500, x:260+43, y:ARENA_H-10-43, element: document.getElementById("pl1"), isTower:true, team:"player", lastShotMs:0, shieldCharges:0},
    {hp:200, maxHp:200, x:460+43, y:ARENA_H-10-43, element: document.getElementById("pl2"), isTower:true, team:"player", lastShotMs:0, shieldCharges:0}
];

let aiTowers = [
    {hp:200, maxHp:200, x:60+43, y:10+43, element: document.getElementById("ai0"), isTower:true, team:"ai", lastShotMs:0, shieldCharges:0},
    {hp:500, maxHp:500, x:260+43, y:10+43, element: document.getElementById("ai1"), isTower:true, team:"ai", lastShotMs:0, shieldCharges:0},
    {hp:200, maxHp:200, x:460+43, y:10+43, element: document.getElementById("ai2"), isTower:true, team:"ai", lastShotMs:0, shieldCharges:0}
];

let playerUnits = [];
let aiUnits = [];
let projectiles = [];
let playerMegaMini = null; // Mega Mini P.E.K.K.A control reference
const megaMiniKeys = { ArrowUp: false, ArrowDown: false, ArrowLeft: false, ArrowRight: false };

function setLog(msg){
    logEl.innerText = msg;
}

function aliveTowerCount(side){
    const arr = (side === "player") ? playerTowers : aiTowers;
    return arr.filter(t => t.hp > 0).length;
}

function middleTowerAlive(side){
    const arr = (side === "player") ? playerTowers : aiTowers;
    return !!(arr[1] && arr[1].hp > 0);
}

function getTimeLeftMs(nowMs){
    if(!matchStartMs) return MATCH_MS;
    return Math.max(0, MATCH_MS - (nowMs - matchStartMs));
}

function updateHudTimeAndTrophies(nowMs){
    if(timeLeftEl){
        if(inSuddenDeath){
            timeLeftEl.textContent = "Sudden death";
        }else{
            const t = getTimeLeftMs(nowMs);
            const s = Math.ceil(t/1000);
            const mm = Math.floor(s/60);
            const ss = String(s%60).padStart(2,'0');
            timeLeftEl.textContent = `${mm}:${ss}`;
        }
    }
    if(trophiesEl){
        trophiesEl.textContent = `üèÜ ${trophies}`;
    }
}

function applySuddenDeathDrain(dtSec){
    const dmg = SUDDEN_DEATH_TOWER_DRAIN_PER_SEC * dtSec;
    if(dmg <= 0) return;
    for(const t of playerTowers){
        if(t.hp <= 0) continue;
        t.hp = Math.max(0, t.hp - dmg);
        renderTower(t);
    }
    for(const t of aiTowers){
        if(t.hp <= 0) continue;
        t.hp = Math.max(0, t.hp - dmg);
        renderTower(t);
    }
}

function arenaCoordsFromEvent(e){
    const rect = arena.getBoundingClientRect();
    const scaleX = ARENA_W / rect.width;
    const scaleY = ARENA_H / rect.height;
    const x = (e.clientX - rect.left) * scaleX;
    const y = (e.clientY - rect.top) * scaleY;
    return { x, y };
}

function updateHud(){
    elixirEl.innerText = elixir;
    aiElixirEl.innerText = aiElixir;
    elixirFillEl.style.width = (elixir/10*100)+"%";

    updateHudTimeAndTrophies(performance.now());
    
    // Update stats display
    if(statsEl){
        const total = stats.wins + stats.losses;
        const winRate = total > 0 ? Math.round(stats.wins / total * 100) : 0;
        const streakDisplay = stats.winStreak > 0 ? ` üî• ${stats.winStreak}` : "";
        statsEl.innerText = `üìä W: ${stats.wins} L: ${stats.losses} (${winRate}%)${streakDisplay}`;
    }

    updateMoleAbilityUi();

    if(gameStarted) renderHand();
}

function shuffle(arr){
    for(let i = arr.length - 1; i > 0; i--){
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
}

function initHands(){
    const pool = getUnlockedPool();
    playerHand = shuffle([...pool]).slice(0, HAND_SIZE);
    // AI cannot use Mega Mini P.E.K.K.A (card 27)
    const aiPool = pool.filter(id => id !== 27);
    aiHand = shuffle([...aiPool]).slice(0, HAND_SIZE);
}

// Fish is a permanent decoration in hand UI (not a card)

function drawReplacement(currentHand, usedCardId, pool){
    const inHand = new Set(currentHand);
    const options = pool.filter(id => !inHand.has(id) && id !== usedCardId);
    if(options.length === 0){
        // fallback (shouldn't happen with pool>hand)
        const fallback = pool.filter(id => !inHand.has(id));
        return fallback.length ? fallback[Math.floor(Math.random()*fallback.length)] : usedCardId;
    }
    return options[Math.floor(Math.random()*options.length)];
}

function replaceUsedCardInHand(hand, usedCardId){
    const idx = hand.indexOf(usedCardId);
    if(idx === -1) return;
    const pool = (hand === playerHand && playerDeck.length) ? playerDeck : getUnlockedPool();
    const next = drawReplacement(hand, usedCardId, pool);
    hand[idx] = next;
}

function renderDeckPicker(){
    const grid = document.getElementById("deckGrid");
    const hint = document.getElementById("deckHint");
    const startBtn = document.getElementById("deckStart");
    if(!grid || !hint || !startBtn) return;

    grid.innerHTML = "";
    const pool = getUnlockedPool();
    for(const id of pool){
        const card = cards[id];
        const btn = document.createElement("button");
        btn.innerText = `${card.emoji} ${card.name} (${card.cost})`;
        if(selectedDeck.has(id)) btn.classList.add("picked");
        btn.onclick = ()=>{
            if(selectedDeck.has(id)){
                selectedDeck.delete(id);
            } else {
                if(selectedDeck.size >= HAND_SIZE) return;
                selectedDeck.add(id);
            }
            renderDeckPicker();
        };
        grid.appendChild(btn);
    }
    hint.innerText = `Vybr√°no: ${selectedDeck.size} / ${HAND_SIZE}`;
    startBtn.disabled = selectedDeck.size !== HAND_SIZE;
}

function startGame(){
    if(selectedDeck.size !== HAND_SIZE) return;
    gameStarted = true;
    gameOver = false;
    playerDeck = [...selectedDeck];
    playerHand = [...playerDeck];
    aiHand = pickAiStartHandDifferent();
    playerMegaMini = null; // Reset Mega Mini P.E.K.K.A at start
    
    // Reset game state
    elixir = 0;
    aiElixir = 0;
    selectedCard = null;
    clearBattlefield();
    
    // Reset towers
    playerTowers.forEach((t, i) => {
        t.hp = t.maxHp;
        t.shieldCharges = 0;
        renderTower(t);
    });
    aiTowers.forEach((t, i) => {
        t.hp = t.maxHp;
        t.shieldCharges = 0;
        renderTower(t);
    });

    matchStartMs = performance.now();
    inSuddenDeath = false;

    // Hide lobby and show game
    const lobbyOverlay = document.getElementById("lobbyOverlay");
    if(lobbyOverlay) lobbyOverlay.classList.add("hidden");
    
    const overlay = document.getElementById("deckOverlay");
    if(overlay) overlay.classList.add("hidden");
    updateHud();
}

function renderHand(){
    const ui = document.getElementById("ui");
    ui.innerHTML = "";
    for(const id of playerHand){
        const card = cards[id];
        if(!card) continue;
        const btn = document.createElement("button");
        btn.innerHTML = `${card.emoji} ${card.name}<br><small>${card.cost}</small>`;
        btn.disabled = gameOver || elixir < card.cost;
        if(selectedCard === id) btn.classList.add("selected");
        btn.onclick = ()=>selectCard(id);
        ui.appendChild(btn);
    }
}

function initTowerUi(t){
    t.element.innerHTML = "<div class='tower-value'></div><div class='tower-hpbar'><div class='tower-hpfill'></div></div>";
    t.valueEl = t.element.querySelector(".tower-value");
    t.hpFillEl = t.element.querySelector(".tower-hpfill");
    renderTower(t);
}

function renderTower(t){
    if(!t.valueEl || !t.hpFillEl) return;
    if(t.hp <= 0){
        t.valueEl.innerText = "‚ùå";
        t.hpFillEl.style.width = "0%";
        t.element.style.filter = "grayscale(1) brightness(.8)";
        return;
    }
    t.valueEl.innerText = t.hp + (t.shieldCharges && t.shieldCharges > 0 ? " üõ°Ô∏è" : "");
    t.hpFillEl.style.width = Math.max(0, (t.hp/t.maxHp*100)) + "%";
}

playerTowers.forEach(initTowerUi);
aiTowers.forEach(initTowerUi);

function selectCard(c){
    if(!playerHand.includes(c)) return;
    selectedCard = c;
    setLog("Vybr√°na karta: " + cards[c].name + " (" + cards[c].cost + ")");
    updateHud();
    hideSpellPreview();
}

arena.addEventListener("mousemove", (e)=>{
    const { x, y } = arenaCoordsFromEvent(e);
    updateSpellPreview(x, y);
});

arena.addEventListener("mouseleave", ()=>{
    hideSpellPreview();
});

arena.onclick = function(e){
    if(!selectedCard) return;
    if(!gameStarted) return;
    if(gameOver) return;
    if(!playerHand.includes(selectedCard)){
        selectedCard = null;
        updateHud();
        return;
    }
    const { x, y } = arenaCoordsFromEvent(e);
    const card = cards[selectedCard];

    hideSpellPreview();

    if(card && card.type === "spell"){
        // Spells can be cast anywhere
        const ok = castSpell(x, y, selectedCard, true);
        if(ok){
            lastPlayerUsedCardId = selectedCard;
            replaceUsedCardInHand(playerHand, selectedCard);
            selectedCard = null;
            updateHud();
        }
        return;
    }

    if(y > (ARENA_H/2)){ // pouze spodn√≠ polovina
        const ok = spawnUnit(x, y, selectedCard, true);
        if(ok){
            lastPlayerUsedCardId = selectedCard;
            replaceUsedCardInHand(playerHand, selectedCard);
            selectedCard = null;
            updateHud();
        }
    } else {
        // Krtek can be placed anywhere
        if(selectedCard === 15){
            const ok = spawnUnit(x, y, selectedCard, true);
            if(ok){
                lastPlayerUsedCardId = selectedCard;
                replaceUsedCardInHand(playerHand, selectedCard);
                selectedCard = null;
                updateHud();
                return;
            }
        }
        setLog("Jednotku m≈Ø≈æe≈° polo≈æit jen do spodn√≠ poloviny.");
    }
};

document.addEventListener("keydown", (ev)=>{
    if(!gameStarted || gameOver) return;
    if(!playerRotWall || playerRotWall.hp <= 0) return;

    const step = 15;
    if(ev.key === "ArrowLeft"){
        playerRotWall.rotDeg = (playerRotWall.rotDeg || 0) - step;
        renderUnit(playerRotWall);
        ev.preventDefault();
    } else if(ev.key === "ArrowRight"){
        playerRotWall.rotDeg = (playerRotWall.rotDeg || 0) + step;
        renderUnit(playerRotWall);
        ev.preventDefault();
    }
});

// jednotky data
const cards = {
    // Slower balance
    1:{name:"Ryt√≠≈ô", emoji:"üó°Ô∏è", hp:90, dmg:14, cost:3, speed:60, range:18, attackCdMs:900},
    2:{name:"Luƒçi≈°tnice", emoji:"üèπ", hp:65, dmg:11, cost:2, speed:68, range:120, attackCdMs:1200, projectile:true},
    3:{name:"Obr", emoji:"üóø", hp:190, dmg:22, cost:5, speed:46, range:20, attackCdMs:1350},
    5:{name:"Mega ryt√≠≈ô", emoji:"üõ°Ô∏èüí•", hp:260, dmg:0, cost:6, speed:62, range:22, attackCdMs:1000, slam:{radius:80, dmg:50}, cleaveRadius:36},
    6:{name:"Raketa", emoji:"üöÄ", cost:6, type:"spell", target:"enemy", rocket:{radius:90, dmgUnits:500, dmgTowers:100}},
    7:{name:"≈†t√≠t", emoji:"üõ°Ô∏è", cost:4, type:"spell", target:"ally", shield:{addCharges:1, pickRadius:95}},
    8:{name:"Skeleton Army", emoji:"üíÄ", cost:3, spawn:{count:6, spread:34}, unit:{name:"Kostlivec", emoji:"üíÄ", hp:10, dmg:5, speed:78, range:18, attackCdMs:980}},
    9:{name:"P.E.K.K.A", emoji:"ü§ñ‚öîÔ∏è", hp:100, maxHp:200, dmg:100, cost:7, speed:44, range:20, attackCdMs:2200},
    10:{name:"X-bow", emoji:"üèπ", hp:180, dmg:10, cost:6, speed:0, range:240, attackCdMs:650, projectile:true, decayPerSec:7},
    11:{name:"Heal Spirit", emoji:"üíöüëª", hp:1, dmg:0, cost:1, speed:92, range:0, attackCdMs:999999,
        lifetimeMs:5000,
        healer:{radius:68, pct:0.05, cdMs:950, preferDamaged:true, includeTowers:true}},
    12:{name:"Zeƒè", emoji:"", hp:200, dmg:0, cost:3, speed:0, range:0, attackCdMs:999999, decayPerSec:10}
    ,13:{name:"Zap", emoji:"‚ö°", cost:2, type:"spell", target:"enemy", zap:{radius:90, dmg:30}}
    ,14:{name:"Goblin barell", emoji:"üõ¢Ô∏èüë∫", cost:3, type:"spell", target:"enemy",
        barrel:{radius:90, count:3, spread:24, unit:{name:"Goblin", emoji:"üë∫", hp:20, dmg:10, speed:80, range:18, attackCdMs:900}}}
    ,15:{name:"Krtek", emoji:"üï≥Ô∏èüêæ", hp:50, dmg:25, cost:3, speed:72, range:18, attackCdMs:900}
    ,20:{name:"Neviditeln√Ω Ryt√≠≈ô üëª", emoji:"üëª", hp:90, dmg:14, cost:3, speed:60, range:18, attackCdMs:900, invisible:true, invisibleCdMs:3000}
    ,21:{name:"Obr Vrh üí™", emoji:"üí™", hp:190, dmg:22, cost:5, speed:92, range:20, attackCdMs:1350, ultOnDeath:true}
    ,25:{name:"Sniper üéØ", emoji:"üéØ", hp:180, dmg:10, cost:6, speed:0, range:9999, attackCdMs:650, projectile:true, sniper:true}
    ,26:{name:"Skeleton King üëë", emoji:"üëë", hp:200, dmg:50, cost:8, speed:40, range:20, attackCdMs:1200, golem:true}
    ,27:{name:"Mega Mini P.E.K.K.A ü§ñ", emoji:"ü§ñ", hp:500, dmg:250, cost:10, speed:100, range:30, attackCdMs:800, manualControl:true}
};

function createUnitInstance(base, x, y, isPlayer, cardId){
    const unitEl = document.createElement("div");
    unitEl.className = "unit " + (isPlayer ? "player" : "ai");
    if(cardId === 10) unitEl.classList.add("xbow-emoji");
    if(cardId === 12) unitEl.classList.add("wall");

    let valueEl = null;
    if(cardId === 10){
        valueEl = document.createElement("div");
        valueEl.className = "unit-value";
        valueEl.innerText = String(base.hp);
        unitEl.appendChild(valueEl);
    }

    const faceEl = document.createElement("div");
    faceEl.className = "unit-face";
    faceEl.innerText = base.emoji;
    unitEl.appendChild(faceEl);
    const hpEl = document.createElement("div");
    hpEl.className = "unit-hp";
    const hpFillEl = document.createElement("div");
    hpFillEl.className = "unit-hpfill";
    hpEl.appendChild(hpFillEl);
    unitEl.appendChild(hpEl);
    arena.appendChild(unitEl);

    const data = {
        id: crypto.randomUUID ? crypto.randomUUID() : String(Math.random()).slice(2),
        cardId,
        name: base.name,
        emoji: base.emoji,
        hp: base.hp,
        maxHp: (base.maxHp ?? base.hp),
        dmg: base.dmg,
        speed: base.speed, // px/s
        range: base.range,
        attackCdMs: base.attackCdMs,
        projectile: !!base.projectile,
        isPlayer,
        x: clamp(x, 20, ARENA_W-20),
        y: clamp(y, 20, ARENA_H-20),
        lastAttackMs: 0,
        lastHealMs: 0,
        lastLeapMs: 0,
        leapsDone: 0,
        spawnedAtMs: performance.now(),
        frozenUntilMs: 0,
        lifeMs: (base.lifetimeMs ?? null),
        rotDeg: 0,
        element: unitEl,
        hpFillEl,
        faceEl,
        facingRad: 0,
        valueEl,
        isInvisible: cardId === 20,
        invisibleUntilMs: cardId === 20 ? performance.now() + 1000 : 0,
        lastInvisibleHitMs: cardId === 20 ? performance.now() : 0,
        sniperTarget: null, // Sniper's designated target (cardId 25)
        attachedTower: null, // Sniper attached tower reference
        golemAbilityStartMs: cardId === 26 ? performance.now() : 0, // Golem ability start time
        lastSkeletonSpawnMs: cardId === 26 ? performance.now() : 0 // Last skeleton spawn time
    };
    
    // Add unit ID to element for clicking
    unitEl.dataset.unitId = data.id;

    if(isPlayer) playerUnits.push(data); else aiUnits.push(data);
    renderUnit(data);

    // Sniper: attach to nearest tower
    if(cardId === 25){
        const towers = isPlayer ? playerTowers : aiTowers;
        if(towers.length > 0){
            const nearest = towers.reduce((best, t) => 
                Math.hypot(t.x - x, t.y - y) < Math.hypot(best.x - x, best.y - y) ? t : best
            );
            data.attachedTower = nearest;
            data.x = nearest.x;
            data.y = nearest.y;
            renderUnit(data);
        }
    }
    
    // Sniper: add click handler to select target
    if(cardId === 25 && isPlayer){
        unitEl.style.cursor = "crosshair";
        unitEl.dataset.sniperOwner = data.id;
    }

    // MR: don't allow an instant jump right after placement
    if(cardId === 5){
        data.lastLeapMs = data.spawnedAtMs;
    }

    if(isPlayer && cardId === 12){
        playerRotWall = data;
    }

    // Mega Mini P.E.K.K.A: store reference and set up click handling
    if(cardId === 27 && isPlayer){
        playerMegaMini = data;
        data.clickToAttack = null; // Will be set by player clicks
        unitEl.style.cursor = "pointer";
    }

    if(isPlayer && cardId === 15){
        playerMole = data;
        updateMoleAbilityUi();
    }
    return data;
}

function spawnUnit(x,y,cardId,isPlayer){
    const base = cards[cardId];
    if(!base) return false;
    if(base.type === "spell") return false;
    const cost = base.cost;

    if(isPlayer){
        if(elixir < cost){
            setLog("Nem√°≈° dost elix√≠ru.");
            return false;
        }
        elixir -= cost;
    } else {
        if(aiElixir < cost) return false;
        aiElixir -= cost;
    }

    // Skeleton Army: spawn 6 skeletons around click point
    if(cardId === 8 && base.spawn && base.unit){
        const n = base.spawn.count;
        const spread = base.spawn.spread;
        for(let i=0;i<n;i++){
            const ang = (Math.PI*2) * (i/n) + (Math.random()*0.6);
            const r = (spread*0.35) + Math.random()*spread;
            const sx = x + Math.cos(ang)*r;
            const sy = y + Math.sin(ang)*r;
            createUnitInstance(base.unit, sx, sy, isPlayer, 8);
        }
        return true;
    }

    const data = createUnitInstance(base, x, y, isPlayer, cardId);

    // special: Mega knight landing AoE
    if(cardId === 5 && base.slam){
        // landing VFX only (MR's damage comes from jumps)
        spawnExplosion(data.x, data.y, "slam");
    }

    return true;
}

function spawnExplosion(x, y, kind){
    const el = document.createElement("div");
    el.className = "explosion" + (kind ? (" " + kind) : "");
    el.style.left = x + "px";
    el.style.top = y + "px";
    arena.appendChild(el);
    setTimeout(()=>{ try{ el.remove(); } catch(e){} }, 650);
}

function castSpell(x, y, cardId, isPlayer){
    const base = cards[cardId];
    if(!base || base.type !== "spell") return false;

    const cost = base.cost;
    if(isPlayer){
        if(elixir < cost){
            setLog("Nem√°≈° dost elix√≠ru.");
            return false;
        }
        elixir -= cost;
    } else {
        if(aiElixir < cost) return false;
        aiElixir -= cost;
    }


    if(cardId === 6 && base.rocket){
        const tx = clamp(x, 20, ARENA_W-20);
        const ty = clamp(y, 20, ARENA_H-20);
        spawnExplosion(tx, ty, "rocket");

        const enemiesUnits = isPlayer ? aiUnits : playerUnits;
        const enemiesTowers = isPlayer ? aiTowers : playerTowers;
        for(const u of enemiesUnits){
            if(u.hp <= 0) continue;
            if(Math.hypot(u.x - tx, u.y - ty) <= base.rocket.radius){
                applyDamage(u, base.rocket.dmgUnits);
            }
        }
        for(const t of enemiesTowers){
            if(t.hp <= 0) continue;
            if(Math.hypot(t.x - tx, t.y - ty) <= base.rocket.radius){
                applyDamage(t, base.rocket.dmgTowers);
            }
        }
        setLog((isPlayer?"Ty":"AI") + " pou≈æil(a) raketu!");
        return true;
    }

    if(cardId === 13 && base.zap){
        const tx = clamp(x, 20, ARENA_W-20);
        const ty = clamp(y, 20, ARENA_H-20);
        spawnExplosion(tx, ty, "rocket");

        const enemiesUnits = isPlayer ? aiUnits : playerUnits;
        const enemiesTowers = isPlayer ? aiTowers : playerTowers;
        for(const u of enemiesUnits){
            if(u.hp <= 0) continue;
            if(Math.hypot(u.x - tx, u.y - ty) <= base.zap.radius){
                applyDamage(u, base.zap.dmg);
            }
        }
        for(const t of enemiesTowers){
            if(t.hp <= 0) continue;
            if(Math.hypot(t.x - tx, t.y - ty) <= base.zap.radius){
                applyDamage(t, base.zap.dmg);
            }
        }
        setLog((isPlayer?"Ty":"AI") + " pou≈æil(a) zap!");
        return true;
    }

    if(cardId === 14 && base.barrel){
        const tx = clamp(x, 20, ARENA_W-20);
        const ty = clamp(y, 20, ARENA_H-20);
        spawnExplosion(tx, ty, "rocket");

        const spawnX = tx;
        const spawnY = ty;
        const n = base.barrel.count || 3;
        const spread = base.barrel.spread || 22;
        for(let i=0;i<n;i++){
            const ang = (Math.PI*2) * (i/n) + (Math.random()*0.6);
            const r = (spread*0.35) + Math.random()*spread;
            const sx = spawnX + Math.cos(ang)*r;
            const sy = spawnY + Math.sin(ang)*r;
            createUnitInstance(base.barrel.unit, sx, sy, isPlayer, 14);
        }

        setLog((isPlayer?"Ty":"AI") + " pou≈æil(a) Goblin barell!");
        return true;
    }

    if(cardId === 7 && base.shield){
        // choose nearest allied tower to click
        const towers = isPlayer ? playerTowers : aiTowers;
        let best = null;
        let bestD = Infinity;
        for(const t of towers){
            if(t.hp <= 0) continue;
            const d = Math.hypot(t.x - x, t.y - y);
            if(d < bestD){ bestD = d; best = t; }
        }

        if(!best || bestD > base.shield.pickRadius){
            setLog("Klikni bl√≠≈æ k vƒõ≈æi, na kterou chce≈° d√°t ≈°t√≠t.");
            return false;
        }

        best.shieldCharges = (best.shieldCharges || 0) + base.shield.addCharges;
        renderTower(best);
        spawnExplosion(best.x, best.y, "rocket");
        setLog((isPlayer?"Ty":"AI") + " dal(a) ≈°t√≠t na vƒõ≈æ!");
        return true;
    }

    return false;
}

function findTarget(unit){
    const enemies = unit.isPlayer ? aiUnits : playerUnits;
    const towers = unit.isPlayer ? aiTowers : playerTowers;

    // MR (Mega ryt√≠≈ô): targets only enemy units (never towers)
    if(unit.cardId === 5){
        let best = null;
        let bestD = Infinity;
        for(const e of enemies){
            if(e.hp <= 0) continue;
            if(e.cardId === 12) continue;
            if(e.cardId === 20 && e.isInvisible) continue; // Neviditeln√Ω ryt√≠≈ô je neviditeln√Ω
            if(e.cardId === 25) continue; // Sniper je neviditeln√Ω
            const d = Math.hypot(unit.x - e.x, unit.y - e.y);
            if(d < bestD){ bestD = d; best = e; }
        }
        return best;
    }

    // Obr jde jen na vƒõ≈æe
    if(unit.cardId === 3){
        // ...a tak√© na X-bow (bere se jako budova)
        let best = null;
        let bestD = Infinity;
        for(const t of towers){
            if(t.hp <= 0) continue;
            const d = Math.hypot(unit.x - t.x, unit.y - t.y);
            if(d < bestD){ bestD = d; best = t; }
        }
        for(const e of enemies){
            if(e.hp <= 0) continue;
            if(e.cardId !== 10) continue;
            const d = Math.hypot(unit.x - e.x, unit.y - e.y);
            if(d < bestD){ bestD = d; best = e; }
        }
        return best;
    }

    // Golem: targets X-bow and towers only
    if(unit.cardId === 26){
        let best = null;
        let bestD = Infinity;
        for(const t of towers){
            if(t.hp <= 0) continue;
            const d = Math.hypot(unit.x - t.x, unit.y - t.y);
            if(d < bestD){ bestD = d; best = t; }
        }
        for(const e of enemies){
            if(e.hp <= 0) continue;
            if(e.cardId !== 10 && e.cardId !== 25) continue; // X-bow a Sniper
            const d = Math.hypot(unit.x - e.x, unit.y - e.y);
            if(d < bestD){ bestD = d; best = e; }
        }
        return best;
    }

    // Luƒçi≈°tnice st≈ô√≠l√≠ jen na jednotky (vƒõ≈æe ignoruje jako c√≠l pro √∫tok)
    if(unit.cardId === 2){
        let best = null;
        let bestD = Infinity;
        for(const e of enemies){
            if(e.hp <= 0) continue;
            if(e.cardId === 12) continue;
            if(e.cardId === 20 && e.isInvisible) continue; // Neviditeln√Ω ryt√≠≈ô je neviditeln√Ω
            if(e.cardId === 25) continue; // Sniper je neviditeln√Ω
            const d = Math.hypot(unit.x - e.x, unit.y - e.y);
            if(d < bestD){ bestD = d; best = e; }
        }
        // kdy≈æ nejsou nep≈ô√°telsk√© jednotky, luƒçi≈°tnice nejde na vƒõ≈æe
        return best;
    }

    // Ostatn√≠: nejbli≈æ≈°√≠ c√≠l (jednotka nebo vƒõ≈æ)
    let best = null;
    let bestD = Infinity;
    for(const e of enemies){
        if(e.hp <= 0) continue;
        if(e.cardId === 12) continue;
        if(e.cardId === 20 && e.isInvisible) continue; // Neviditeln√Ω ryt√≠≈ô je neviditeln√Ω
        if(e.cardId === 25) continue; // Sniper je neviditeln√Ω
        const d = Math.hypot(unit.x - e.x, unit.y - e.y);
        if(d < bestD){ bestD = d; best = e; }
    }
    for(const t of towers){
        if(t.hp <= 0) continue;
        const d = Math.hypot(unit.x - t.x, unit.y - t.y);
        if(d < bestD){ bestD = d; best = t; }
    }
    return best;
}

function clamp(v, a, b){
    return Math.max(a, Math.min(b, v));
}

function renderUnit(u){
    u.element.style.left = u.x + "px";
    u.element.style.top = u.y + "px";

    const nowMs = performance.now();
    if(u.frozenUntilMs && nowMs < u.frozenUntilMs){
        u.element.classList.add("frozen");
    } else {
        u.element.classList.remove("frozen");
    }

    // Handle invisibility (card 20) - invisible until target found
    if(u.cardId === 20){
        if(u.isInvisible){
            u.element.style.opacity = "0.15";
            u.element.style.filter = "saturate(0) brightness(0.5)";
        } else {
            u.element.style.opacity = "1";
            u.element.style.filter = "";
        }
    }

    if(u.cardId === 12){
        const deg = (u.rotDeg || 0);
        u.element.style.transform = `translate(-50%, -50%) rotate(${deg}deg)`;
    } else {
        // keep default CSS transform (translate) for regular units
        u.element.style.transform = "";
    }
    u.hpFillEl.style.width = Math.max(0, (u.hp/u.maxHp*100)) + "%";
    if(u.cardId === 10 && u.valueEl){
        u.valueEl.innerText = String(Math.ceil(u.hp));
    }
    // Rotate only the X-bow emoji to face target
    if(u.cardId === 10 && u.faceEl){
        const deg = (u.facingRad || 0) * 180 / Math.PI;
        u.faceEl.style.transform = `rotate(${deg}deg)`;
    } else if(u.cardId === 25 && u.faceEl){
        const deg = (u.facingRad || 0) * 180 / Math.PI;
        u.faceEl.style.transform = `rotate(${deg}deg)`;
    } else if(u.faceEl){
        u.faceEl.style.transform = "";
    }
    if(u.hp <= 0){
        u.element.style.filter = "grayscale(1) brightness(.85)";
        u.element.style.opacity = "0";
    }
}

function removeDead(){
    const keepAlive = (u)=>u.hp>0;
    const removeUnit = (u)=>{ try{ u.element.remove(); } catch(e){} };
    
    playerUnits.filter(u=>u.hp<=0).forEach(removeUnit);
    aiUnits.filter(u=>u.hp<=0).forEach(removeUnit);
    playerUnits = playerUnits.filter(keepAlive);
    aiUnits = aiUnits.filter(keepAlive);
}

function nearestBridgeX(x){
    return BRIDGES_X.reduce((best, bx)=> Math.abs(bx-x) < Math.abs(best-x) ? bx : best, BRIDGES_X[0]);
}

function applyDamage(target, amount, opts = {}){
    if(!target || target.hp <= 0) return;

    // Invisible Knight (card 20) is immune to all attacks
    if(target.cardId === 20) return;

    // Sniper (card 25) is immortal
    if(target.cardId === 25) return;

    // Wall (Zeƒè) is immune to attacks (only decays over time)
    if(!target.isTower && target.cardId === 12) return;

    // Tower shield: absorbs ALL incoming damage once and redirects it to a random enemy tower
    if(target.isTower && !opts.skipShield && amount > 0 && target.shieldCharges && target.shieldCharges > 0){
        target.shieldCharges -= 1;
        renderTower(target);
        spawnExplosion(target.x, target.y, "rocket");

        const enemyTowers = target.team === "player" ? aiTowers : playerTowers;
        const alive = enemyTowers.filter(t=>t.hp>0);
        if(alive.length > 0){
            const redirect = alive[Math.floor(Math.random()*alive.length)];
            applyDamage(redirect, amount, { skipShield:true });
        }
        return;
    }

    const prevHp = target.hp;
    target.hp = Math.max(0, target.hp - amount);
    if(target.isTower){
        renderTower(target);
    } else {
        renderUnit(target);
    }

    // P.E.K.K.A heal on kill (only when it lands the killing blow)
    if(prevHp > 0 && target.hp === 0 && opts.attacker && !opts.attacker.isTower && opts.attacker.cardId === 9){
        opts.attacker.hp = Math.min(opts.attacker.maxHp, opts.attacker.hp + 25);
        renderUnit(opts.attacker);
    }
    
    // Giant (21) death effect: 5s double attack speed for nearby ally
    if(prevHp > 0 && target.hp === 0 && target.cardId === 21){
        const allies = target.isPlayer ? playerUnits : aiUnits;
        let closest = null;
        let closestDist = Infinity;
        for(const ally of allies){
            if(ally.hp > 0 && ally !== target){
                const dist = Math.hypot(ally.x - target.x, ally.y - target.y);
                if(dist < closestDist){
                    closestDist = dist;
                    closest = ally;
                }
            }
        }
        if(closest){
            closest.giantBuffUntilMs = performance.now() + 5000;
        }
    }
}

function applyHeal(target, amount){
    if(!target || target.hp <= 0) return;
    if(amount <= 0) return;
    const prev = target.hp;
    target.hp = Math.min(target.maxHp ?? target.hp, target.hp + amount);
    if(target.hp === prev) return;
    if(target.isTower){
        renderTower(target);
    } else {
        renderUnit(target);
    }
}

function weightedPick(options){
    // options: [{id, w}]
    let sum = 0;
    for(const o of options) sum += o.w;
    let r = Math.random() * sum;
    for(const o of options){
        r -= o.w;
        if(r <= 0) return o.id;
    }
    return options[options.length-1].id;
}

function spawnProjectile(x, y, tx, ty, dmg, team, kind){
    const el = document.createElement("div");
    el.className = "projectile" + (kind ? (" " + kind) : "");
    arena.appendChild(el);
    const speed = 340; // px/s (slower feel)
    const dx = tx - x;
    const dy = ty - y;
    const d = Math.max(1, Math.hypot(dx, dy));
    const vx = dx/d*speed;
    const vy = dy/d*speed;
    const p = {x, y, vx, vy, dmg, team, element: el, lifeMs: 1200, speed};
    projectiles.push(p);
    el.style.left = x + "px";
    el.style.top = y + "px";
}

function spawnHomingProjectile(x, y, target, dmg, team, kind){
    if(!target) return;
    const el = document.createElement("div");
    el.className = "projectile" + (kind ? (" " + kind) : "");
    arena.appendChild(el);
    const speed = 340;
    const dx = target.x - x;
    const dy = target.y - y;
    const d = Math.max(1, Math.hypot(dx, dy));
    const vx = dx/d*speed;
    const vy = dy/d*speed;
    const p = {x, y, vx, vy, dmg, team, element: el, lifeMs: 1200, speed, homing:true, target};
    projectiles.push(p);
    el.style.left = x + "px";
    el.style.top = y + "px";
}

function clearBattlefield(){
    playerUnits.forEach(u=>{ try{ u.element.remove(); } catch(e){} });
    aiUnits.forEach(u=>{ try{ u.element.remove(); } catch(e){} });
    playerUnits = [];
    aiUnits = [];
    projectiles.forEach(p=>{ try{ p.element.remove(); } catch(e){} });
    projectiles = [];
}

function updateProjectiles(dtMs){
    const dt = dtMs / 1000;
    for(const p of projectiles){
        if(p.homing && p.target && p.target.hp > 0){
            const dx = p.target.x - p.x;
            const dy = p.target.y - p.y;
            const d = Math.max(1, Math.hypot(dx, dy));
            const speed = p.speed || 340;
            p.vx = dx/d*speed;
            p.vy = dy/d*speed;
        }
        p.x += p.vx * dt;
        p.y += p.vy * dt;
        p.lifeMs -= dtMs;
        p.element.style.left = p.x + "px";
        p.element.style.top = p.y + "px";
    }

    // collisions: very simple (hit enemy unit OR tower within radius)
    for(const p of projectiles){
        if(p.lifeMs <= 0) continue;
        const enemies = p.team === "player" ? aiUnits : playerUnits;
        const enemyTowers = p.team === "player" ? aiTowers : playerTowers;
        let hit = null;
        for(const e of enemies){
            if(e.hp<=0) continue;
            if(e.cardId === 12) continue;
            if(Math.hypot(p.x - e.x, p.y - e.y) < 18){ hit = e; break; }
        }
        if(!hit){
            for(const t of enemyTowers){
                if(t.hp<=0) continue;
                if(Math.hypot(p.x - t.x, p.y - t.y) < 46){ hit = t; break; }
            }
        }
        if(hit){
            applyDamage(hit, p.dmg);
            p.lifeMs = 0;
        }
    }

    projectiles.filter(p=>p.lifeMs<=0).forEach(p=>{ try{ p.element.remove(); } catch(e){} });
    projectiles = projectiles.filter(p=>p.lifeMs>0);
}

function unitMoveVector(unit, target){
    // NR (Neviditeln√Ω Ryt√≠≈ô) m≈Ø≈æe j√≠t p≈ôes vodu - p≈ôeskakuje ≈ôeku!
    if(unit.cardId === 20){
        const dx = target.x - unit.x;
        const dy = target.y - unit.y;
        const dist = Math.max(1, Math.hypot(dx, dy));
        return {dx, dy, dist};
    }
    
    // Jednotky NESM√ç chodit p≈ôes vodu: p≈ôes ≈ôeku jen po mostƒõ.
    // ≈òe≈°en√≠: waypointy (1) zarovnat se na X mostu na sv√© stranƒõ, (2) doj√≠t k okraji ≈ôeky,
    // (3) p≈ôej√≠t vertik√°lnƒõ po mostƒõ, (4) pokraƒçovat k c√≠li.
    const riverTop = RIVER_Y;
    const riverBottom = RIVER_Y + RIVER_H;
    const inRiver = (y)=> y >= riverTop && y <= riverBottom;
    const needsCross = unit.isPlayer
        ? (unit.y > riverBottom && target.y < riverTop)
        : (unit.y < riverTop && target.y > riverBottom);

    let tx = target.x;
    let ty = target.y;

    if(needsCross || inRiver(unit.y)){
        const bx = nearestBridgeX(unit.x);
        const ALIGN_EPS = 6;
        const EDGE_PAD = 8;

        // 1) nejd≈ô√≠v zarovnat X na most (horizont√°lnƒõ), dokud nejsme v ≈ôece
        if(!inRiver(unit.y) && Math.abs(unit.x - bx) > ALIGN_EPS){
            tx = bx;
            ty = unit.y;
        } else {
            if(unit.isPlayer){
                // hr√°ƒç jde NAHORU (z doln√≠ p≈Ølky do horn√≠)
                if(unit.y > riverBottom + EDGE_PAD){
                    // 2) doj√≠t k doln√≠mu okraji ≈ôeky na X mostu
                    tx = bx;
                    ty = riverBottom + EDGE_PAD;
                } else if(unit.y > riverTop - EDGE_PAD){
                    // 3) p≈ôej√≠t ≈ôeku vertik√°lnƒõ po mostƒõ
                    tx = bx;
                    ty = riverTop - EDGE_PAD;
                } else {
                    // 4) jsme nad ≈ôekou
                    tx = target.x;
                    ty = target.y;
                }
            } else {
                // AI jde DOL≈Æ (z horn√≠ p≈Ølky do doln√≠)
                if(unit.y < riverTop - EDGE_PAD){
                    tx = bx;
                    ty = riverTop - EDGE_PAD;
                } else if(unit.y < riverBottom + EDGE_PAD){
                    tx = bx;
                    ty = riverBottom + EDGE_PAD;
                } else {
                    tx = target.x;
                    ty = target.y;
                }
            }

            // pokud jsme v ≈ôece a nejsme na X mostu, dot√°hni X na most
            if(inRiver(unit.y) && Math.abs(unit.x - bx) > ALIGN_EPS){
                tx = bx;
                ty = unit.y;
            }
        }
    }

    const dx = tx - unit.x;
    const dy = ty - unit.y;
    const dist = Math.max(1, Math.hypot(dx, dy));
    return {dx, dy, dist};
}

function updateUnits(nowMs, dtMs){
    const dt = dtMs / 1000;
    const all = playerUnits.concat(aiUnits);
    for(const u of all){
        if(u.hp <= 0) continue;

        // timed lifetime (e.g., Heal Spirit)
        if(u.lifeMs != null){
            u.lifeMs -= dtMs;
            if(u.lifeMs <= 0){
                u.hp = 0;
                renderUnit(u);
                continue;
            }
        }

        // Self-decay over time (e.g., X-bow, Wall)
        const decay = cards[u.cardId] && cards[u.cardId].decayPerSec;
        if(decay){
            u.hp = Math.max(0, u.hp - decay * dt);
            if(u.hp <= 0){
                renderUnit(u);
                continue;
            }
            // keep decay visible even if it currently has no target
            renderUnit(u);
        }
        
        // Sniper: stick to attached tower and die if tower dies
        if(u.cardId === 25 && u.attachedTower){
            if(u.attachedTower.hp <= 0){
                // Tower died, Sniper dies too
                u.hp = 0;
                renderUnit(u);
                continue;
            }
            // Move with tower
            u.x = u.attachedTower.x;
            u.y = u.attachedTower.y;
            renderUnit(u);
        }
        
        // Skeleton King ability: spawn skeleton every 2 seconds indefinitely
        if(u.cardId === 26 && u.hp > 0){
            if(nowMs - u.lastSkeletonSpawnMs >= 2000){
                u.lastSkeletonSpawnMs = nowMs;
                // Spawn skeleton (skeleton unit from card 8)
                const skeleton = {
                    name: "Kostlivec", 
                    emoji: "üíÄ", 
                    hp: 10, 
                    dmg: 5, 
                    speed: 78, 
                    range: 18, 
                    attackCdMs: 980
                };
                createUnitInstance(skeleton, u.x + (Math.random() - 0.5) * 40, u.y + (Math.random() - 0.5) * 40, u.isPlayer, 999);
            }
        }
        
        // Heal Spirit: heals nearby allies by 5% while alive
        if(u.cardId === 11 && cards[11] && cards[11].healer){
            const healer = cards[11].healer;
            const allyUnits = u.isPlayer ? playerUnits : aiUnits;
            const allyTowers = u.isPlayer ? playerTowers : aiTowers;

            let best = null;
            let bestScore = -1;
            // prefer most damaged (ratio), tie-break by distance
            for(const a of allyUnits){
                if(a.hp <= 0) continue;
                if(a === u) continue;
                if(a.hp >= a.maxHp) continue;
                const dmgRatio = (a.maxHp - a.hp) / a.maxHp;
                const d = Math.hypot(u.x - a.x, u.y - a.y);
                const score = dmgRatio * 1000 - d;
                if(score > bestScore){ bestScore = score; best = a; }
            }
            if(healer.includeTowers){
                for(const t of allyTowers){
                    if(t.hp <= 0) continue;
                    if(t.hp >= t.maxHp) continue;
                    const dmgRatio = (t.maxHp - t.hp) / t.maxHp;
                    const d = Math.hypot(u.x - t.x, u.y - t.y);
                    const score = dmgRatio * 1000 - d;
                    if(score > bestScore){ bestScore = score; best = t; }
                }
            }
            // if nobody is damaged, just hang near closest allied middle tower
            if(!best){
                const t = allyTowers[1] || allyTowers[0];
                if(t && t.hp > 0) best = t;
            }

            if(best){
                const d = Math.hypot(u.x - best.x, u.y - best.y);
                if(d <= healer.radius && nowMs - (u.lastHealMs || 0) >= healer.cdMs){
                    const amount = (best.maxHp ?? best.hp) * healer.pct;
                    applyHeal(best, amount);
                    u.lastHealMs = nowMs;
                }
                if(u.speed > 0 && d > healer.radius * 0.75){
                    const dx = best.x - u.x;
                    const dy = best.y - u.y;
                    const dist = Math.max(1, Math.hypot(dx, dy));
                    const step = u.speed * dt;
                    u.x += (dx/dist) * step;
                    u.y += (dy/dist) * step;
                    u.x = clamp(u.x, 18, ARENA_W-18);
                    u.y = clamp(u.y, 18, ARENA_H-18);
                }
            }
            renderUnit(u);
            continue;
        }

        // Frozen units can't move or attack
        if(u.frozenUntilMs && nowMs < u.frozenUntilMs){
            renderUnit(u);
            continue;
        }

        // Mega Mini P.E.K.K.A: manual control with arrow keys + click to attack
        if(u.cardId === 27 && u.isPlayer){
            // Handle movement from arrow keys
            const moveSpeed = u.speed * dt;
            let moveX = 0, moveY = 0;
            if(megaMiniKeys.ArrowLeft) moveX -= moveSpeed;
            if(megaMiniKeys.ArrowRight) moveX += moveSpeed;
            if(megaMiniKeys.ArrowUp) moveY -= moveSpeed;
            if(megaMiniKeys.ArrowDown) moveY += moveSpeed;
            
            if(moveX !== 0 || moveY !== 0){
                u.x = clamp(u.x + moveX, 18, ARENA_W-18);
                u.y = clamp(u.y + moveY, 18, ARENA_H-18);
                // Face direction of movement
                if(moveX !== 0 || moveY !== 0){
                    u.facingRad = Math.atan2(moveY, moveX);
                }
            }
            
            // Handle attack if click target is set
            if(u.clickToAttack){
                const targetX = u.clickToAttack.x;
                const targetY = u.clickToAttack.y;
                const dToTarget = Math.hypot(u.x - targetX, u.y - targetY);
                
                if(nowMs - u.lastAttackMs >= u.attackCdMs){
                    u.lastAttackMs = nowMs;
                    // Deal damage to all enemies in a small radius around click point
                    const hitRadius = 60;
                    const enemies = aiUnits;
                    let hitCount = 0;
                    for(const e of enemies){
                        if(e.hp <= 0) continue;
                        if(Math.hypot(e.x - targetX, e.y - targetY) <= hitRadius){
                            applyDamage(e, u.dmg, { attacker: u });
                            hitCount++;
                        }
                    }
                    if(hitCount > 0){
                        setLog(`ü§ñ Mega Mini P.E.K.K.A zas√°hla ${hitCount} c√≠l(e)!`);
                        spawnExplosion(targetX, targetY, "rocket");
                    }
                    u.clickToAttack = null; // Reset after attack
                }
            }
            
            renderUnit(u);
            continue;
        }

        let target = findTarget(u);
        // Safety: MR should never go for towers
        if(u.cardId === 5 && target && target.isTower) target = null;
        
        // Sniper: use designated target if available, only targets units (not towers)
        if(u.cardId === 25){
            if(u.sniperTarget && u.sniperTarget.hp > 0 && !u.sniperTarget.isTower){
                target = u.sniperTarget;
            } else {
                u.sniperTarget = null;
                continue;
            }
        }
        
        // MR: if there are no enemy units, go fully back and wait
        if(!target && u.cardId === 5){
            const backY = u.isPlayer ? (ARENA_H - 32) : 32;
            const dy = backY - u.y;
            const dist = Math.abs(dy);
            if(dist > 2){
                const step = u.speed * dt;
                u.y = clamp(u.y + Math.sign(dy) * Math.min(step, dist), 18, ARENA_H-18);
                renderUnit(u);
            }
            continue;
        }
        if(!target) continue;

        if(u.cardId === 10){
            u.facingRad = Math.atan2(target.y - u.y, target.x - u.x);
        }
        
        if(u.cardId === 25){
            u.facingRad = Math.atan2(target.y - u.y, target.x - u.x);
        }

        const dToTarget = Math.hypot(u.x - target.x, u.y - target.y);
        const inRange = dToTarget <= u.range;
        const canAttackTarget = !(u.cardId === 2 && target.isTower) && !(u.cardId === 5 && target.isTower);
        if(inRange && canAttackTarget){
            // Check if Giant buff is active (2x attack speed = 0.5x cooldown)
            let effectiveCdMs = u.attackCdMs;
            if(u.giantBuffUntilMs && nowMs < u.giantBuffUntilMs){
                effectiveCdMs = u.attackCdMs * 0.5; // 2x faster
            }
            
            if(nowMs - u.lastAttackMs >= effectiveCdMs){
                u.lastAttackMs = nowMs;
                
                if(u.projectile){
                    const kind = u.projectileKind || (cards[u.cardId] && cards[u.cardId].projectileKind);
                    if(u.cardId === 2 || u.cardId === 10 || u.cardId === 25){
                        spawnHomingProjectile(u.x, u.y, target, u.dmg, u.isPlayer ? "player" : "ai", kind);
                    } else {
                        spawnProjectile(u.x, u.y, target.x, target.y, u.dmg, u.isPlayer ? "player" : "ai", kind);
                    }
                } else {
                    // Mega knight cleave: hit multiple enemies in a small area
                    if(u.cardId === 5 && cards[5].cleaveRadius && !target.isTower){
                        const radius = cards[5].cleaveRadius;
                        const enemies = u.isPlayer ? aiUnits : playerUnits;
                        for(const e of enemies){
                            if(e.hp<=0) continue;
                            if(Math.hypot(e.x - target.x, e.y - target.y) <= radius){
                                // MR: normal hit does 0 dmg, but knocks + freezes
                                const knockDist = 240; // ~2x "d√©lka mostu"
                                const freezeMs = 5000;
                                const dir = u.isPlayer ? -1 : 1;
                                e.y = clamp(e.y + dir * knockDist, 18, ARENA_H-18);
                                e.frozenUntilMs = Math.max(e.frozenUntilMs || 0, nowMs + freezeMs);
                                renderUnit(e);
                            }
                        }
                    } else {
                        if(u.cardId === 5 && target && !target.isTower && target.hp > 0 && target.cardId !== 12){
                            const knockDist = 240; // ~2x "d√©lka mostu"
                            const freezeMs = 5000;
                            const dir = u.isPlayer ? -1 : 1;
                            target.y = clamp(target.y + dir * knockDist, 18, ARENA_H-18);
                            target.frozenUntilMs = Math.max(target.frozenUntilMs || 0, nowMs + freezeMs);
                            renderUnit(target);
                        } else {
                            applyDamage(target, u.dmg, { attacker: u });
                        }
                    }
                }
            }
        } else {
            // MR: doesn't walk. It jumps to the nearest enemy unit
            // and deals the same AoE slam damage as on spawn.
            if(u.cardId === 5 && cards[5] && cards[5].slam){
                const leapCdMs = 4500;
                const maxLeaps = 4;
                const initialDelayMs = 2000;
                if(
                    (u.leapsDone || 0) < maxLeaps &&
                    nowMs - (u.spawnedAtMs || 0) >= initialDelayMs &&
                    nowMs - (u.lastLeapMs || 0) >= leapCdMs
                ){
                    const enemies = u.isPlayer ? aiUnits : playerUnits;
                    let best = null;
                    let bestD = Infinity;
                    for(const e of enemies){
                        if(e.hp <= 0) continue;
                        // ignore walls as leap targets
                        if(e.cardId === 12) continue;
                        const d = Math.hypot(u.x - e.x, u.y - e.y);
                        if(d < bestD){ bestD = d; best = e; }
                    }
                    if(best){
                        u.lastLeapMs = nowMs;
                        u.leapsDone = (u.leapsDone || 0) + 1;
                        u.x = clamp(best.x, 18, ARENA_W-18);
                        u.y = clamp(best.y, 18, ARENA_H-18);

                        spawnExplosion(u.x, u.y, "slam");
                        const radius = cards[5].slam.radius;
                        const dmg = cards[5].slam.dmg;
                        for(const e of enemies){
                            if(e.hp <= 0) continue;
                            if(Math.hypot(e.x - u.x, e.y - u.y) <= radius){
                                applyDamage(e, dmg);
                            }
                        }
                    }
                }
            } else {
                // buildings (e.g., X-bow) don't move
                if(u.speed > 0){
                    const vec = unitMoveVector(u, target);
                    const step = u.speed * dt;
                    let nx = u.x + (vec.dx/vec.dist) * step;
                    let ny = u.y + (vec.dy/vec.dist) * step;
                    nx = clamp(nx, 18, ARENA_W-18);
                    ny = clamp(ny, 18, ARENA_H-18);

                    // Wall rule: enemies can't pass through, allies can.
                    // Implemented as collision against enemy walls only.
                    const enemyWalls = u.isPlayer ? aiUnits : playerUnits;
                    const UNIT_R = 22;
                    const WALL_HW = 44; // 88px / 2
                    const WALL_HH = 6;  // 12px / 2
                    let blocked = false;
                    for(const w of enemyWalls){
                        if(w.hp <= 0) continue;
                        if(w.cardId !== 12) continue;
                        const ang = ((w.rotDeg || 0) * Math.PI) / 180;
                        const dx = nx - w.x;
                        const dy = ny - w.y;
                        const ca = Math.cos(-ang);
                        const sa = Math.sin(-ang);
                        const lx = dx * ca - dy * sa;
                        const ly = dx * sa + dy * ca;
                        if(Math.abs(lx) <= (WALL_HW + UNIT_R) && Math.abs(ly) <= (WALL_HH + UNIT_R)){
                            blocked = true;
                            break;
                        }
                    }

                    if(!blocked){
                        u.x = nx;
                        u.y = ny;
                    }
                }
            }
        }
        renderUnit(u);
    }
}

function pickTowerTarget(tower){
    const enemies = tower.team === "player" ? aiUnits : playerUnits;
    // vƒõ≈æ si hl√≠d√° hlavnƒõ svou polovinu, ale kdy≈æ nic nen√≠, bere nejbli≈æ≈°√≠
    const halfOk = (u)=> tower.team === "player" ? u.y >= (ARENA_H/2 - 10) : u.y <= (ARENA_H/2 + 10);
    let candidates = enemies.filter(u=>u.hp>0 && u.cardId !== 12 && halfOk(u));
    if(candidates.length === 0) candidates = enemies.filter(u=>u.hp>0 && u.cardId !== 12);
    let best = null;
    let bestD = Infinity;
    for(const u of candidates){
        const d = Math.hypot(tower.x - u.x, tower.y - u.y);
        if(d < bestD){ bestD = d; best = u; }
    }
    return {unit: best, dist: bestD};
}

function updateTowers(nowMs){
    const towers = playerTowers.concat(aiTowers);
    // Towers should reach only a bit before the bridge
    const range = 140;
    const archerCdMs = (cards[2] && cards[2].attackCdMs) ? cards[2].attackCdMs : 1200;
    const archerDmg = (cards[2] && cards[2].dmg) ? cards[2].dmg : 10;
    const cannonCdMs = archerCdMs + 500;
    const cannonDmg = 50;
    for(const t of towers){
        if(t.hp<=0) continue;
        const picked = pickTowerTarget(t);
        if(!picked.unit) continue;
        if(picked.dist > range) continue;

        const isMiddle = t.maxHp >= 500;
        const shotCdMs = isMiddle ? cannonCdMs : archerCdMs;
        const dmg = isMiddle ? cannonDmg : archerDmg;
        const kind = isMiddle ? "stone" : "arrow";

        if(nowMs - t.lastShotMs < shotCdMs) continue;
        t.lastShotMs = nowMs;
        spawnHomingProjectile(t.x, t.y, picked.unit, dmg, t.team, kind);
    }
}

function resetTowers(){
    const towers = playerTowers.concat(aiTowers);
    for(const t of towers){
        t.hp = t.maxHp;
        t.shieldCharges = 0;
        t.lastShotMs = 0;
        if(t.element) t.element.style.filter = "";
        renderTower(t);
    }
}

function resetGame(keepSameDeck){
    clearBattlefield();
    resetTowers();

    playerRotWall = null;
    playerMole = null;
    moleCooldownUntilMs = 0;

    elixir = 5;
    aiElixir = 5;
    selectedCard = null;
    hideSpellPreview();
    lastAiSpawnMs = 0;
    lastAiUnitCardId = null;
    lastTickMs = performance.now();
    gameOver = false;
    matchStartMs = 0;
    inSuddenDeath = false;

    if(endPanelEl){
        endPanelEl.classList.add("hidden");
        endPanelEl.dataset.mode = "";
        endPanelEl.innerHTML = "";
    }

    endOverlayEl.classList.add("hidden");

    if(keepSameDeck && playerDeck && playerDeck.length === HAND_SIZE){
        gameStarted = true;
        playerHand = [...playerDeck];
        aiHand = pickAiStartHandDifferent();
        matchStartMs = performance.now();
        inSuddenDeath = false;
        const overlay = document.getElementById("deckOverlay");
        if(overlay) overlay.classList.add("hidden");
        updateHud();
        setLog("Hraje≈° se stejn√Ωm bal√≠ƒçkem.");
        return;
    }

    // back to deck picker
    gameStarted = false;
    playerDeck = [];
    selectedDeck = new Set();
    playerHand = [];
    aiHand = [];
    const ui = document.getElementById("ui");
    if(ui) ui.innerHTML = "";
    const overlay = document.getElementById("deckOverlay");
    if(overlay) overlay.classList.remove("hidden");
    renderDeckPicker();
    updateHud();
    setLog("Vyber 4 karty pro novou hru.");
}

function resetGameRandom(){
    clearBattlefield();
    resetTowers();

    playerRotWall = null;
    playerMole = null;
    moleCooldownUntilMs = 0;

    elixir = 5;
    aiElixir = 5;
    selectedCard = null;
    hideSpellPreview();
    lastAiSpawnMs = 0;
    lastAiUnitCardId = null;
    lastTickMs = performance.now();
    gameOver = false;
    matchStartMs = 0;
    inSuddenDeath = false;

    if(endPanelEl){
        endPanelEl.classList.add("hidden");
        endPanelEl.dataset.mode = "";
        endPanelEl.innerHTML = "";
    }

    endOverlayEl.classList.add("hidden");

    // start immediately with 4 random cards
    gameStarted = true;
    const pool = getUnlockedPool();
    playerDeck = shuffle([...pool]).slice(0, HAND_SIZE);
    playerHand = [...playerDeck];
    selectedDeck = new Set(playerDeck);
    aiHand = pickAiStartHandDifferent();
    matchStartMs = performance.now();
    inSuddenDeath = false;
    const overlay = document.getElementById("deckOverlay");
    if(overlay) overlay.classList.add("hidden");
    updateHud();
    setLog("Hraje≈° s n√°hodn√Ωmi kartami.");
}

function endMatch(playerWon, reasonMsg){
    if(gameOver) return;
    gameOver = true;
    selectedCard = null;
    playerMegaMini = null; // Reset Mega Mini P.E.K.K.A reference

    // freeze match state
    inSuddenDeath = false;
    matchStartMs = 0;

    const remaining = aliveTowerCount("player");
    const delta = trophyDelta(playerWon, remaining);
    trophies += delta;
    saveTrophies();
    pushLeaderboardEntry();
    
    // Update stats with win streak
    if(playerWon){
        stats.wins++;
        stats.winStreak = (stats.winStreak || 0) + 1;
        stats.gamesSinceLastSpin = (stats.gamesSinceLastSpin || 0) + 1;
        // Bonus trophies for win streak = winStreak count
        trophies += stats.winStreak;
        saveTrophies();
    }else{
        stats.losses++;
        stats.winStreak = 0;
        stats.gamesSinceLastSpin = (stats.gamesSinceLastSpin || 0) + 1;
    }
    
    // Add spin every 10 games
    const totalGames = stats.wins + stats.losses;
    const spinsEarned = Math.floor(totalGames / 10);
    stats.spinCount = spinsEarned;
    
    saveStats();

    updateHud();
    clearBattlefield();
    endTextEl.innerText = playerWon ? "Vyhr√°l jsi! üéâ" : "Prohr√°l jsi! üò¢";
    if(endPanelEl){
        endPanelEl.classList.add("hidden");
        endPanelEl.dataset.mode = "";
        endPanelEl.innerHTML = "";
    }
    setLog(`${reasonMsg} (${delta>=0?"+":""}${delta}üèÜ)`);
    
    // Go to lobby instead of showing end overlay
    setTimeout(() => openLobby(), 1500);
}

function checkGameOver(nowMs){
    if(gameOver) return;

    // Immediate win/loss if middle tower is destroyed
    const pMid = middleTowerAlive("player");
    const aMid = middleTowerAlive("ai");
    if(!pMid || !aMid){
        if(!pMid && !aMid){
            // Rare simultaneous: decide by remaining towers
            const pc = aliveTowerCount("player");
            const ac = aliveTowerCount("ai");
            if(pc !== ac) return endMatch(pc > ac, "Konec ‚Äì padly prost≈ôedn√≠ vƒõ≈æe");
            // still tied, treat as loss (simplest)
            return endMatch(false, "Konec ‚Äì padly prost≈ôedn√≠ vƒõ≈æe");
        }
        return endMatch(!!pMid && !aMid, "Konec ‚Äì padla prost≈ôedn√≠ vƒõ≈æ");
    }

    // Time limit -> tower count
    const timeLeft = getTimeLeftMs(nowMs);
    const isSuddenDeathActive = timeLeft < 60000 && timeLeft > 0;
    
    if(timeLeft <= 0 && !inSuddenDeath){
        const pc = aliveTowerCount("player");
        const ac = aliveTowerCount("ai");
        if(pc !== ac){
            return endMatch(pc > ac, "Konec ƒçasu");
        }
        inSuddenDeath = true;
        setLog("Sudden death - 2x elixir!");
    }

    if(inSuddenDeath){
        const pc = aliveTowerCount("player");
        const ac = aliveTowerCount("ai");
        if(pc !== ac){
            return endMatch(pc > ac, "Sudden death ‚Äì padla vƒõ≈æ");
        }
    }
}

if(endSameBtn) endSameBtn.onclick = ()=>resetGame(true);
if(endNewBtn) endNewBtn.onclick = ()=>resetGame(false);
if(endRandomBtn) endRandomBtn.onclick = ()=>resetGameRandom();

function openGift(){
    const modal = document.getElementById("giftModal");
    if(modal) {
        modal.classList.remove("hidden");
        const input = document.getElementById("giftInput");
        if(input) input.focus();
        const msg = document.getElementById("giftMessage");
        if(msg) msg.innerText = "";
    }
}

function closeGift(){
    const modal = document.getElementById("giftModal");
    if(modal) modal.classList.add("hidden");
}

function checkGift(){
    const input = document.getElementById("giftInput");
    const msg = document.getElementById("giftMessage");
    if(!input || !msg) return;
    
    const answer = input.value.toLowerCase().trim();
    if(answer === "v√°noce" || answer === "vanoce"){
        // Random upgrade: 20 = Invisible Knight, 21 = Giant
        const upgrade = Math.random() < 0.5 ? 20 : 21;
        localStorage.setItem(UPGRADE_KEY, String(upgrade));
        const upgradeName = upgrade === 20 ? "Neviditeln√Ω Ryt√≠≈ô üëª" : "Obr Vrh üí™";
        msg.innerHTML = `üéÑ Spr√°vnƒõ! Dost√°v√°≈° upgrade: ${upgradeName}<br>Pou≈æij jej v p≈ô√≠≈°t√≠ h≈ôe! üéÅ‚ú®`;
        msg.style.color = "#ffd700";
        input.disabled = true;
        setTimeout(()=>{
            closeGift();
            input.disabled = false;
            input.value = "";
        }, 4000);
    }else{
        msg.innerText = "≈†patnƒõ! Zkus to znovu...";
        msg.style.color = "#ef4444";
        input.value = "";
    }
}

const endGiftBtn = document.getElementById("endGift");
if(endGiftBtn) endGiftBtn.onclick = openGift;

document.getElementById("giftInput")?.addEventListener("keypress", (e)=>{
    if(e.key === "Enter") checkGift();
});

// Spin wheel logic
const SPIN_REWARDS = [
    { label: "1 üèÜ", trophies: 1 },
    { label: "10 üèÜ", trophies: 10 },
    { label: "Random", trophies: null }, // null = random card
    { label: "100 üèÜ", trophies: 100 },
    { label: "1 üèÜ", trophies: 1 },
    { label: "1000 üèÜ", trophies: 1000 },
];

let wheelRotation = 0;
let spinning = false;

function openSpin(){
    const modal = document.getElementById("spinModal");
    if(modal) {
        modal.classList.remove("hidden");
        updateSpinInfo();
        drawSpinWheel();
    }
}

function closeSpin(){
    const modal = document.getElementById("spinModal");
    if(modal) modal.classList.add("hidden");
}

function openLobby(){
    const endOverlay = document.getElementById("endOverlay");
    const lobbyOverlay = document.getElementById("lobbyOverlay");
    if(endOverlay) endOverlay.classList.add("hidden");
    if(lobbyOverlay) lobbyOverlay.classList.remove("hidden");
    updateLobbyInfo();
}

function closeLobby(){
    const lobbyOverlay = document.getElementById("lobbyOverlay");
    if(lobbyOverlay) lobbyOverlay.classList.add("hidden");
}

function updateLobbyInfo(){
    const trophyEl = document.getElementById("lobbyTrophies");
    if(trophyEl) trophyEl.innerText = String(trophies);
}

function updateSpinInfo(){
    const info = document.getElementById("spinInfo");
    const btn = document.getElementById("spinButton");
    const spinsAvailable = stats.spinCount || 0;
    if(info) info.innerText = `Dostupn√© spiny: ${spinsAvailable}`;
    if(btn) btn.innerText = `Toƒçit (${spinsAvailable})`;
}

function drawSpinWheel(){
    const canvas = document.getElementById("spinCanvas");
    if(!canvas) return;
    const ctx = canvas.getContext("2d");
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;
    const radius = 120;
    
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    
    const sliceAngle = (Math.PI * 2) / SPIN_REWARDS.length;
    
    for(let i = 0; i < SPIN_REWARDS.length; i++){
        const startAngle = i * sliceAngle + wheelRotation;
        const endAngle = (i + 1) * sliceAngle + wheelRotation;
        
        // Slice background
        const hue = (i * 60) % 360;
        ctx.fillStyle = `hsl(${hue}, 70%, 50%)`;
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, startAngle, endAngle);
        ctx.lineTo(centerX, centerY);
        ctx.fill();
        
        // Border
        ctx.strokeStyle = "rgba(255,255,255,.5)";
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.arc(centerX, centerY, radius, startAngle, endAngle);
        ctx.lineTo(centerX, centerY);
        ctx.stroke();
        
        // Label
        const midAngle = (startAngle + endAngle) / 2;
        const labelX = centerX + Math.cos(midAngle) * (radius * 0.7);
        const labelY = centerY + Math.sin(midAngle) * (radius * 0.7);
        ctx.fillStyle = "white";
        ctx.font = "bold 12px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(SPIN_REWARDS[i].label, labelX, labelY);
    }
    
    // Center circle
    ctx.fillStyle = "rgba(0,0,0,.5)";
    ctx.beginPath();
    ctx.arc(centerX, centerY, 15, 0, Math.PI * 2);
    ctx.fill();
    
    // Pointer at top
    ctx.fillStyle = "#ffa500";
    ctx.beginPath();
    ctx.moveTo(centerX, 5);
    ctx.lineTo(centerX - 10, 25);
    ctx.lineTo(centerX + 10, 25);
    ctx.fill();
}

function spinWheel(){
    if(spinning) return;
    
    if(stats.spinCount <= 0){
        alert(`Nem√°≈° dostupn√© spiny! Mus√≠≈° hr√°t 10 her aby ses z√≠skal jeden spin.`);
        return;
    }
    
    spinning = true;
    const btn = document.getElementById("spinButton");
    if(btn) btn.disabled = true;
    
    // Spin animation
    const duration = 3000; // 3 seconds
    const startTime = performance.now();
    const spins = 5 + Math.random() * 3; // 5-8 full rotations
    const targetIndex = Math.floor(Math.random() * SPIN_REWARDS.length);
    const targetRotation = (targetIndex / SPIN_REWARDS.length) * Math.PI * 2;
    
    function animateSpin(currentTime){
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);
        
        // Ease out effect
        const easeProgress = 1 - Math.pow(1 - progress, 3);
        wheelRotation = (spins * Math.PI * 2 * easeProgress + targetRotation) % (Math.PI * 2);
        
        drawSpinWheel();
        
        if(progress < 1){
            requestAnimationFrame(animateSpin);
        } else {
            spinning = false;
            const reward = SPIN_REWARDS[targetIndex];
            
            if(reward.trophies !== null){
                trophies += reward.trophies;
                saveTrophies();
                alert(`üéâ Vyhr√°l jsi ${reward.trophies} trofej√≠! üèÜ`);
            } else {
                // Random card
                const cards_list = [1,2,3,4,6,7,8,9,11,13,15,16,17,18,19];
                const randomCard = cards_list[Math.floor(Math.random() * cards_list.length)];
                const cardName = cards[randomCard].name;
                alert(`üéâ Vyhr√°l jsi kartu: ${cardName}!`);
            }
            
            // Decrement spin count
            stats.spinCount = Math.max(0, stats.spinCount - 1);
            saveStats();
            updateSpinInfo();
            if(btn) btn.disabled = false;
        }
    }
    
    requestAnimationFrame(animateSpin);
}

const endSpinBtn = document.getElementById("endSpin");
if(endSpinBtn) endSpinBtn.onclick = openSpin;

// Lobby buttons
const lobbyPlayBtn = document.getElementById("lobbyPlay");
const lobbySpin = document.getElementById("lobbySpin");
const lobbyTrophyRoad = document.getElementById("lobbyTrophyRoad");
const lobbyLeaderboard = document.getElementById("lobbyLeaderboard");

if(lobbyPlayBtn) lobbyPlayBtn.onclick = () => { closeLobby(); initGame(); };
if(lobbySpin) lobbySpin.onclick = openSpin;
if(lobbyTrophyRoad) lobbyTrophyRoad.onclick = () => {
    const content = document.getElementById("lobbyContent");
    if(content) content.innerHTML = trophyRoadHtml();
};
if(lobbyLeaderboard) lobbyLeaderboard.onclick = () => {
    const content = document.getElementById("lobbyContent");
    if(content) content.innerHTML = leaderboardHtml();
};

document.getElementById("giftInput")?.addEventListener("keypress", (e)=>{
    if(e.key === "Enter") checkGift();
});

function aiThink(nowMs){
    if(gameOver) return;
    if(nowMs - lastAiSpawnMs < 950) return;
    if(Math.random() < 0.48) return; // Slightly more aggressive

    // Game state analysis
    const aiTowerCount = aliveTowerCount("ai");
    const playerTowerCount = aliveTowerCount("player");
    const timeLeftMs = getTimeLeftMs(nowMs);
    const isSuddenDeath = timeLeftMs < 60000 && timeLeftMs > 0;
    const isWinning = aiTowerCount > playerTowerCount;
    const isLosing = aiTowerCount < playerTowerCount;
    const isLateGame = timeLeftMs < 30000 || isSuddenDeath;
    const playerUnitsCount = playerUnits.filter(u=>u.hp>0).length;
    const enemyUnits = playerUnits.filter(u=>u.hp>0);
    const enemyTowers = playerTowers.filter(t=>t.hp>0);
    
    // AI now "knows" player's hand (sees all player cards)
    const playerHandCards = playerHand || [];

    // Priority 1: Use spells on critical situations
    
    // Raketa (Rocket 6) - high priority for chip damage and unit clusters
    if(aiHand.includes(6) && cards[6] && aiElixir >= cards[6].cost){
        let rocketThreshold = isLosing ? 0.35 : (isWinning ? 0.12 : 0.24);
        if(isSuddenDeath) rocketThreshold = 0.45; // Much more aggressive in sudden death
        
        if(Math.random() < rocketThreshold){
            let best = null;
            let bestScore = 0;
            
            // preferuj shluk jednotek
            for(const u of enemyUnits){
                const score = enemyUnits.reduce((acc, v)=> acc + (Math.hypot(v.x-u.x, v.y-u.y) <= cards[6].rocket.radius ? 1 : 0), 0);
                if(score > bestScore){ bestScore = score; best = {x:u.x, y:u.y}; }
            }

            // v pozdn√≠ h≈ôe/sudden death zamƒõ≈ô se na vƒõ≈æ
            if(isLateGame && enemyTowers.length > 0){
                const midTower = playerTowers[1];
                if(midTower && midTower.hp > 0){
                    best = {x: midTower.x, y: midTower.y};
                    bestScore = 1;
                }
            }

            if(best && bestScore >= (isLosing ? 1 : (isSuddenDeath ? 1 : 2))){
                const ok = castSpell(best.x, best.y, 6, false);
                if(ok){
                    lastAiSpawnMs = nowMs;
                    lastAiUsedCardId = 6;
                    replaceUsedCardInHand(aiHand, 6);
                }
                return;
            }

            // fallback: tref nejslab≈°√≠ vƒõ≈æ
            if(enemyTowers.length>0){
                enemyTowers.sort((a,b)=>a.hp-b.hp);
                const t = enemyTowers[0];
                const ok = castSpell(t.x, t.y, 6, false);
                if(ok){
                    lastAiSpawnMs = nowMs;
                    lastAiUsedCardId = 6;
                    replaceUsedCardInHand(aiHand, 6);
                }
                return;
            }
        }
    }

    // Zap (Lightning 13) - faster attack on units/towers
    if(aiHand.includes(13) && cards[13] && aiElixir >= cards[13].cost){
        let zapThreshold = isLosing ? 0.38 : (isWinning ? 0.16 : 0.32);
        if(isSuddenDeath) zapThreshold = 0.50; // Much more aggressive in sudden death
        
        if(Math.random() < zapThreshold){
            let best = null;
            let bestScore = 0;
            
            // preferuj shluky jednotek
            for(const u of enemyUnits){
                const score = enemyUnits.reduce((acc, v)=> acc + (Math.hypot(v.x-u.x, v.y-u.y) <= cards[13].zap.radius ? 1 : 0), 0);
                if(score > bestScore){ bestScore = score; best = {x:u.x, y:u.y}; }
            }

            if(best && bestScore >= (isLosing ? 1 : (isSuddenDeath ? 1 : 2))){
                const ok = castSpell(best.x, best.y, 13, false);
                if(ok){
                    lastAiSpawnMs = nowMs;
                    lastAiUsedCardId = 13;
                    replaceUsedCardInHand(aiHand, 13);
                }
                return;
            }

            // fallback na vƒõ≈æ
            if(enemyTowers.length>0){
                enemyTowers.sort((a,b)=>a.hp-b.hp);
                const t = enemyTowers[0];
                const ok = castSpell(t.x, t.y, 13, false);
                if(ok){
                    lastAiSpawnMs = nowMs;
                    lastAiUsedCardId = 13;
                    replaceUsedCardInHand(aiHand, 13);
                }
                return;
            }
        }
    }

    // Priority 2: Defense - dej ≈°t√≠t na po≈°kozenou vƒõ≈æ kdy≈æ je zraniteln√°
    if(aiHand.includes(7) && cards[7] && aiElixir >= cards[7].cost){
        let defenseThreshold = isLosing ? 0.30 : (isWinning ? 0.06 : 0.10);
        if(isSuddenDeath) defenseThreshold = 0.08; // Less defense in sudden death - go aggressive
        
        if(Math.random() < defenseThreshold){
            const alive = aiTowers.filter(t=>t.hp>0);
            if(alive.length>0){
                alive.sort((a,b)=> (a.hp/a.maxHp) - (b.hp/b.maxHp));
                const t = alive[0];
                const hpRatio = t.hp / t.maxHp;
                // obrana je d≈Øle≈æitƒõj≈°√≠ kdy≈æ je vƒõ≈æ zraniteln√°
                if(hpRatio < 0.65){
                    const ok = castSpell(t.x, t.y, 7, false);
                    if(ok){
                        lastAiSpawnMs = nowMs;
                        lastAiUsedCardId = 7;
                        replaceUsedCardInHand(aiHand, 7);
                    }
                    return;
                }
            }
        }
    }

    // Priority 3: Skel barrel - chip damage na vƒõ≈æ (kdy≈æ je v ruce)
    if(aiHand.includes(14) && cards[14] && aiElixir >= cards[14].cost){
        let barrelThreshold = isLosing ? 0.28 : (isWinning ? 0.08 : 0.18);
        if(isSuddenDeath) barrelThreshold = 0.35; // More aggressive in sudden death
        
        if(Math.random() < barrelThreshold){
            const enemyTowers = playerTowers.filter(t=>t.hp>0);
            if(enemyTowers.length>0){
                enemyTowers.sort((a,b)=>a.hp-b.hp);
                const t = enemyTowers[0];
                const ok = castSpell(t.x, t.y, 14, false);
                if(ok){
                    lastAiSpawnMs = nowMs;
                    lastAiUsedCardId = 14;
                    replaceUsedCardInHand(aiHand, 14);
                }
                return;
            }
        }
    }

    // Priority 4: Spawn jednotky - adaptivn√≠ strategie
    const affordable = [1,2,3,5,8,9,10,11,12].filter(id=>aiHand.includes(id) && cards[id].cost <= aiElixir);
    const options = affordable.map(id=>{
        const c = cards[id];
        let w = Math.pow(c.cost, 1.35);
        
        // Z√°kladn√≠ v√°hy
        if(id === 2) w *= 0.55;  // Luƒçi≈°tnice - slab≈°√≠
        if(id === 1) w *= 1.10;  // Ryt√≠≈ô - silnƒõj≈°√≠
        
        // Adaptivn√≠ v√°hy dle situace
        if(isLosing){
            // Kdy≈æ prohr√°v√°m, preferuj dra≈æ≈°√≠ jednotky (silnƒõj≈°√≠)
            w *= 1.25;
            if(id === 1) w *= 1.40; // Ryt√≠≈ô je silnƒõj≈°√≠
        }else if(isWinning && !isSuddenDeath){
            // Kdy≈æ vyhr√°v√°m (bez sudden death), m√©nƒõ investuj
            w *= 0.70;
        }
        
        // V sudden death jdi v≈°echno - maxim√°ln√≠ agrese
        if(isSuddenDeath){
            w *= 1.50; // Velmi agresivn√≠
            if([1,3,5,8,9].includes(id)) w *= 1.30; // Preferuj siln√© jednotky
        }
        
        // Pokud m√° nep≈ô√≠tel hodnƒõ jednotek, preferuj AoE/silnƒõj≈°√≠
        if(playerUnitsCount > 4){
            if([3,5,8,9,10].includes(id)) w *= 1.25;
        }
        
        return { id, w };
    });
    if(options.length === 0) return;

    let card = weightedPick(options);
    // avoid repeating same unit too often
    if(lastAiUnitCardId && card === lastAiUnitCardId && options.length > 1 && Math.random() < 0.75){
        const others = options.filter(o=>o.id !== lastAiUnitCardId);
        card = weightedPick(others);
    }

    // Spawn strategie - chytr√© um√≠stƒõn√≠
    let x, y;
    const biasBridge = Math.random() < 0.7;
    
    if(biasBridge){
        // Okolo most≈Ø - strategie podle situace
        const bridgeX = Math.random()<0.5 ? BRIDGES_X[0] : BRIDGES_X[1];
        x = bridgeX + (Math.random()*90 - 45);
    }else{
        // Random spawn kdy chceme nƒõco speci√°ln√≠ho
        x = Math.random()*ARENA_W;
    }
    
    y = 58 + Math.random()*60;
    
    const ok = spawnUnit(x, y, card, false);
    if(ok){
        lastAiSpawnMs = nowMs;
        lastAiUnitCardId = card;
        lastAiUsedCardId = card;
        replaceUsedCardInHand(aiHand, card);
    }
}

// elix√≠r regen (plynulej≈°√≠) - s 2x v posledn√≠ minutƒõ
setInterval(()=>{
    if(gameOver) return;
    if(!gameStarted) return;
    const timeLeftMs = getTimeLeftMs(performance.now());
    const isSuddenDeath = timeLeftMs < 60000 && timeLeftMs > 0;
    const multiplier = isSuddenDeath ? SUDDEN_DEATH_ELIXIR_MULTIPLIER : 1;
    elixir = Math.min(elixir + 1 * multiplier, 10);
    aiElixir = Math.min(aiElixir + 1 * multiplier, 10);
    updateHud();
}, 2500);

function gameLoop(nowMs){
    const dtMs = Math.min(40, nowMs - lastTickMs); // clamp kv≈Øli tab switch
    lastTickMs = nowMs;

    if(!gameStarted){
        requestAnimationFrame(gameLoop);
        return;
    }

    updateHudTimeAndTrophies(nowMs);

    aiThink(nowMs);
    updateTowers(nowMs);
    updateUnits(nowMs, dtMs);
    updateProjectiles(dtMs);
    removeDead();

    if(inSuddenDeath){
        applySuddenDeathDrain(dtMs / 1000);
    }

    checkGameOver(nowMs);

    requestAnimationFrame(gameLoop);
}

renderDeckPicker();
document.getElementById("deckStart").onclick = startGame;
updateHud();

// Open lobby on startup
openLobby();

// Keyboard controls for Mega Mini P.E.K.K.A
document.addEventListener("keydown", (e)=>{
    if(e.key === "ArrowUp" || e.key === "ArrowDown" || e.key === "ArrowLeft" || e.key === "ArrowRight"){
        megaMiniKeys[e.key] = true;
        e.preventDefault();
    }
});

document.addEventListener("keyup", (e)=>{
    if(e.key === "ArrowUp" || e.key === "ArrowDown" || e.key === "ArrowLeft" || e.key === "ArrowRight"){
        megaMiniKeys[e.key] = false;
        e.preventDefault();
    }
});

// Click to attack with Mega Mini P.E.K.K.A
arena.addEventListener("click", (e)=>{
    if(!gameStarted || gameOver || !playerMegaMini || playerMegaMini.hp <= 0) return;
    const rect = arena.getBoundingClientRect();
    const x = (e.clientX - rect.left) * (ARENA_W / rect.width);
    const y = (e.clientY - rect.top) * (ARENA_H / rect.height);
    playerMegaMini.clickToAttack = { x, y };
    setLog("ü§ñ Mega Mini P.E.K.K.A se zamƒõ≈ôuje...");
});

requestAnimationFrame(gameLoop);
</script>

</body>
</html>
